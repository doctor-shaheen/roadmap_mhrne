<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roadmap to Biostatistics & Computational Modeling in Mental Health Research</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap');

        :root {
            --primary-color: #00d9ff;
            --secondary-color: #0066cc;
            --accent-color: #ff6b6b;
            --light-accent-color: #4ecdc4;
            --danger-color: #ff4757;
            --warning-color: #ffa502;
            --success-color: #2ed573;
            --bg-color: #0a0e27;
            --dark-bg: #141b2d;
            --text-color: #e1e8ed;
            --light-text-color: #ffffff;
            --card-bg: #1e2749;
            --dark-card-bg: #141b2d;
            --border-radius: 16px;
            --box-shadow: 0 15px 35px rgba(0,0,0,0.4);
            --gradient-primary: linear-gradient(135deg, #0a0e27 0%, #141b2d 50%, #1e2749 100%);
            --gradient-secondary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-accent: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --glow-effect: 0 0 20px rgba(0, 217, 255, 0.3);
            --card-border: 1px solid rgba(0, 217, 255, 0.2);
        }

        body {
            font-family: 'Lato', sans-serif;
            background: var(--gradient-primary);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .presentation-container {
            width: 100%;
            height: 100%;
            position: relative;
            flex-grow: 1;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 60px 80px;
            box-sizing: border-box;
            opacity: 0;
            visibility: hidden;
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform: translateX(100px) scale(0.95);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            background: var(--bg-color);
            backdrop-filter: blur(15px);
            border: var(--card-border);
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0) scale(1);
        }

        .slide-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--accent-color);
        }

        .slide-number {
            background: var(--gradient-accent);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.9em;
            box-shadow: var(--box-shadow);
        }

        .slide-title {
            color: var(--primary-color);
            font-size: 2.8em;
            font-weight: 700;
            margin: 0;
            flex-grow: 1;
            margin-left: 30px;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .slide-title-main {
            color: var(--light-text-color);
            text-align: center;
            font-size: 4em;
            font-weight: 700;
            text-shadow: 2px 2px 20px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #ffffff 0%, #f0f9ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #slide-1 {
            background: var(--gradient-primary);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: relative;
        }

        #slide-1::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg"><defs><pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse"><path d="M 100 0 L 0 0 0 100" fill="none" stroke="%23ffffff" stroke-width="0.5" opacity="0.1"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)"/></svg>');
            opacity: 0.3;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.8em;
            text-align: center;
            margin-top: 30px;
            font-weight: 300;
        }
        
        .author {
            color: rgba(255, 255, 255, 0.8);
            margin-top: 60px;
            font-size: 1.4em;
            font-weight: 300;
        }

        .content {
            display: flex;
            gap: 40px;
            width: 100%;
            flex-grow: 1;
        }
        
        .content.vertical {
            flex-direction: column;
        }

        .column {
            flex: 1;
            padding: 0;
        }
        
        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 30px;
            margin-bottom: 30px;
            border: var(--card-border);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-accent);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: var(--glow-effect), var(--box-shadow);
            border: 1px solid rgba(0, 217, 255, 0.5);
        }

        h3 {
            color: var(--primary-color);
            font-size: 1.9em;
            margin-top: 0;
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        h4 {
            color: var(--secondary-color);
            font-size: 1.5em;
            margin-bottom: 15px;
            font-weight: 600;
        }

        p, li {
            font-size: 1.1em;
            line-height: 1.8;
            color: var(--text-color);
        }

        ul {
            padding-left: 25px;
        }

        .definition {
            background: linear-gradient(135deg, rgba(79, 209, 199, 0.1) 0%, rgba(104, 211, 145, 0.1) 100%);
            border-left: 4px solid var(--accent-color);
            padding: 20px;
            margin: 25px 0;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
        }
        
        .definition strong {
            color: var(--primary-color);
            font-weight: 700;
        }

        .mental-health-example {
            background: linear-gradient(135deg, rgba(237, 133, 54, 0.1) 0%, rgba(245, 101, 101, 0.1) 100%);
            border-left: 4px solid var(--warning-color);
            padding: 20px;
            margin: 25px 0;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
        }
        
        .mental-health-example::before {
            content: 'üß† Mental Health Example: ';
            font-weight: 700;
            color: var(--primary-color);
        }

        /* Interactive Elements */
        .interactive-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: #f0f7f8;
            border-radius: var(--border-radius);
        }
        
        .interactive-container label {
            font-weight: 700;
        }
        
        .interactive-container button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        
        .interactive-container button:hover {
            background-color: var(--primary-color);
        }

        .interactive-container input[type="range"], .interactive-container input[type="number"] {
            width: 250px;
        }

        #bayes-output, #coin-flip-output {
            font-weight: 700;
            font-size: 1.2em;
            color: var(--danger-color);
        }
        
        /* Navigation */
        .navigation {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 20px;
            background: rgba(30, 39, 73, 0.95);
            padding: 15px 25px;
            border-radius: 50px;
            box-shadow: var(--glow-effect), var(--box-shadow);
            z-index: 1000;
            border: var(--card-border);
            backdrop-filter: blur(15px);
        }
        
        .nav-btn {
            background: var(--gradient-accent);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 217, 255, 0.3);
        }
        
        .nav-btn:disabled {
            background: linear-gradient(135deg, #555 0%, #333 100%);
            cursor: not-allowed;
            box-shadow: none;
        }
        
        .nav-btn:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 217, 255, 0.5);
        }
        
        #slide-counter {
            font-weight: 700;
            color: var(--primary-color);
            font-size: 1.1em;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .slide-overview {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 39, 73, 0.95);
            border-radius: 15px;
            padding: 15px;
            backdrop-filter: blur(15px);
            border: var(--card-border);
            box-shadow: var(--glow-effect);
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }

        .slide-overview.visible {
            opacity: 1;
            transform: translateX(0);
        }

        .slide-overview h4 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
            font-size: 0.9em;
        }

        .slide-dots {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            max-width: 250px;
            margin: 0 auto;
        }

        .slide-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .slide-dot.active {
            background: var(--primary-color);
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.7);
        }

        .slide-dot:hover {
            transform: scale(1.2);
            background: var(--accent-color);
        }

        .slide-dot::before {
            content: attr(data-slide);
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.65em;
            color: var(--text-color);
            opacity: 0;
            transition: opacity 0.3s ease;
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 1000;
        }

        .slide-dot:hover::before {
            opacity: 1;
        }

        /* Code Blocks */
        pre {
            background: #2d2d2d;
            color: #f1faee;
            padding: 20px;
            border-radius: var(--border-radius);
            overflow-x: auto;
            font-size: 0.9em;
        }
        code.language-python {
            font-family: 'Courier New', Courier, monospace;
        }

        /* Flowchart */
        .flowchart {
            width: 100%;
            text-align: center;
        }
        
        .mermaid {
           background-color: var(--card-bg);
           padding: 20px;
           border-radius: var(--border-radius);
           box-shadow: var(--box-shadow);
        }

        /* DL Optimizer Viz */
        #optimizer-canvas {
            border: 1px solid #ccc;
            background-color: white;
        }
        .optimizer-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .roadmap-list {
            list-style-type: none;
            padding-left: 0;
            counter-reset: roadmap-counter;
        }
        .roadmap-list li {
            counter-increment: roadmap-counter;
            margin-bottom: 20px;
            font-size: 1.3em;
            position: relative;
            padding-left: 50px;
        }
        .roadmap-list li::before {
            content: counter(roadmap-counter);
            position: absolute;
            left: 0;
            top: 0;
            width: 35px;
            height: 35px;
            background-color: var(--secondary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 700;
        }
        
        .reference-list {
            list-style: none;
            padding: 0;
        }
        .reference-list li {
            margin-bottom: 15px;
            padding-left: 25px;
            position: relative;
        }
        .reference-list li::before {
            content: 'üîó';
            position: absolute;
            left: 0;
        }

    </style>
</head>
<body>

    <div class="presentation-container">
        <!-- Slide 1: Title -->
        <div class="slide active" id="slide-1">
            <h1 class="slide-title-main">Roadmap to Biostatistics & Computational Modeling in Mental Health Research</h1>
            <p class="subtitle">A Practical Guide from Foundational Concepts to Advanced Applications</p>
            <p class="author">Ahmed Shaheen</p>
        </div>

        <!-- Slide 2: Roadmap Overview -->
        <div class="slide" id="slide-2">
            <h2 class="slide-title">Our Journey Today: The Roadmap</h2>
            <div class="content">
                <div class="column">
                     <ol class="roadmap-list">
                        <li><b>Foundations:</b> Probability & Descriptive Statistics</li>
                        <li><b>Data Preparation:</b> Preprocessing & Transformation</li>
                        <li><b>Statistical Inference:</b> Choosing Tests & Making Claims</li>
                        <li><b>Intro to Modeling:</b> Supervised vs. Unsupervised Learning</li>
                        <li><b>Classical & ML Models:</b> Regression, SVMs, Decision Trees</li>
                        <li><b>Advanced Modeling:</b> Deep Learning & Optimization</li>
                        <li><b>Specialized Topic:</b> Analyzing Time Series Data</li>
                    </ol>
                </div>
                <div class="column">
                     <div class="mermaid flowchart">
                        graph TD
                            A[Foundations] --> B(Data Prep);
                            B --> C(Inference);
                            C --> D{Modeling};
                            D --> E[Classical/ML];
                            D --> F[Deep Learning];
                            D --> G[Time Series];
                            subgraph "Core Statistics"
                                A
                                B
                                C
                            end
                            subgraph "Modeling Paradigms"
                                D
                                E
                                F
                                G
                            end
                     </div>
                     <p style="text-align: center; margin-top: 20px;">This roadmap guides us from understanding our data to building sophisticated models for mental health research.</p>
                </div>
            </div>
        </div>

        <!-- Slide 3: Probability -->
        <div class="slide" id="slide-3">
            <h2 class="slide-title">3. Probability Foundations & Central Limit Theorem</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Frequentist Probability</h3>
                        <div class="definition">
                            <strong>Definition:</strong> Probability as the long-run frequency of an event over many repeated trials. It's an objective property of the world.
                        </div>
                        <ul>
                            <li>Parameters (e.g., true mean) are fixed, unknown constants.</li>
                            <li>Conclusions are based on p-values and confidence intervals.</li>
                            <li>"If we repeated this experiment infinite times, we would see this result X% of the time."</li>
                        </ul>
                    </div>
                     <div class="card">
                        <h4>Interactive Simulation: Law of Large Numbers</h4>
                        <div class="interactive-container">
                            <label for="flips">Number of Coin Flips: <span id="flips-value">1000</span></label>
                            <input type="range" id="flips" min="10" max="10000" value="1000" step="10">
                            <button onclick="runCoinFlip()">Flip Coins</button>
                            <p id="coin-flip-output">Observed Probability of Heads: ?</p>
                            <canvas id="coin-flip-chart" height="100"></canvas>
                        </div>
                    </div>
                </div>
                <div class="column">
                     <div class="card">
                        <h3>Bayesian Probability</h3>
                        <div class="definition">
                           <strong>Definition:</strong> Probability as a degree of belief or confidence in a statement, which can be updated as new evidence becomes available.
                        </div>
                        <ul>
                            <li>Starts with a <strong>prior belief</strong> about a parameter.</li>
                            <li>Uses observed data (<strong>likelihood</strong>) to update this belief.</li>
                            <li>Results in a <strong>posterior distribution</strong> of belief.</li>
                            <li>"Given the data, our updated belief is that the parameter is likely in this range."</li>
                        </ul>
                    </div>
                    <div class="card">
                         <h4>Interactive Simulation: Bayesian Inference</h4>
                         <p>A new screening tool for depression is developed. Let's find the probability someone actually has depression if they test positive.</p>
                         <div class="interactive-container">
                             <label>Prevalence (Prior): <input type="number" id="prior" value="0.1" step="0.01" max="1"> (10%)</label>
                             <label>Sensitivity (Likelihood): <input type="number" id="sensitivity" value="0.9" step="0.01" max="1"> (90%)</label>
                             <label>Specificity: <input type="number" id="specificity" value="0.8" step="0.01" max="1"> (80%)</label>
                             <button onclick="calculateBayes()">Calculate Posterior</button>
                             <p id="bayes-output">P(Depression | Positive Test) = ?</p>
                         </div>
                    </div>
                    <div class="card">
                        <h3>Central Limit Theorem</h3>
                        <div class="definition">
                            <strong>Theorem:</strong> For sample size n ‚Üí ‚àû, the sampling distribution of the mean approaches normality regardless of the population distribution.
                        </div>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            ‚àön (XÃÑ‚Çô - Œº) ‚Üí·µà N(0, œÉ¬≤)<br>
                            XÃÑ‚Çô ~ N(Œº, œÉ¬≤/n) for large n
                        </p>
                        <p><strong>Practical Implications:</strong></p>
                        <ul>
                            <li>Enables statistical inference even with non-normal populations</li>
                            <li>Justifies use of z-tests and t-tests for large samples (n ‚â• 30)</li>
                            <li>Foundation for confidence intervals and hypothesis testing</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            Even if individual PHQ-9 scores aren't normally distributed, the mean PHQ-9 across patients will be approximately normal for n ‚â• 30.
                        </div>
                        
                        <div class="interactive-container">
                            <label>Sample Size: <input type="range" id="clt-n" min="5" max="100" value="30"> <span id="clt-n-val">30</span></label>
                            <label>Population Distribution: 
                                <select id="clt-dist">
                                    <option value="uniform">Uniform</option>
                                    <option value="exponential">Exponential</option>
                                    <option value="bimodal">Bimodal</option>
                                </select>
                            </label>
                            <button onclick="demonstrateCLT()">Demonstrate CLT</button>
                            <canvas id="clt-chart" height="200"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Slide 4: Descriptive Statistics -->
        <div class="slide" id="slide-4">
            <h2 class="slide-title">4. Descriptive Statistics: Understanding Your Data</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Key Concepts</h3>
                        <h4>Measures of Central Tendency</h4>
                        <ul>
                            <li><b>Mean:</b> The average value. Sensitive to outliers.</li>
                            <li><b>Median:</b> The middle value. Robust to outliers.</li>
                            <li><b>Mode:</b> The most frequent value.</li>
                        </ul>
                        <h4>Measures of Dispersion</h4>
                         <ul>
                            <li><b>Variance / Standard Deviation:</b> How spread out the data is around the mean.</li>
                            <li><b>Range & Interquartile Range (IQR):</b> Measures of total spread and spread of the middle 50%.</li>
                        </ul>
                    </div>
                    <div class="card">
                         <h3>Data Distribution & Normality</h3>
                         <div class="definition">
                             <strong>Normality:</strong> Many statistical tests assume data follows a "normal" or Gaussian (bell-curve) distribution.
                         </div>
                         <ul>
                             <li><b>Skewness:</b> Measures the asymmetry of the distribution.</li>
                             <li><b>Kurtosis:</b> Measures the "tailedness" or heaviness of the tails.</li>
                             <li><b>Normality Tests:</b> Statistical checks like Shapiro-Wilk or Kolmogorov-Smirnov.</li>
                         </ul>
                    </div>
                </div>
                <div class="column">
                     <div class="mental-health-example">
                         Imagine we have Patient Health Questionnaire-9 (PHQ-9) scores for a clinical trial. Descriptive statistics and visualizations are our first step to understand the patient cohort's baseline depression severity.
                     </div>
                     <div class="card">
                         <h4>Exploratory Data Analysis (EDA)</h4>
                         <p>Visualizing data is crucial. Let's look at a sample distribution of PHQ-9 scores.</p>
                         <div class="interactive-container">
                             <canvas id="dist-chart" height="200"></canvas>
                             <p>This histogram shows the frequency of different scores. The overlayed density curve helps visualize the shape.</p>
                         </div>
                     </div>
                </div>
            </div>
        </div>

        <!-- Slide 5: Data Preprocessing -->
        <div class="slide" id="slide-5">
            <h2 class="slide-title">5. Inferential Statistics: From Sample to Population</h2>
             <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Handling Missing Data</h3>
                        <p>Missing data is ubiquitous in longitudinal mental health studies (e.g., patient dropout).</p>
                        <h4>Types of Missingness</h4>
                        <ul>
                            <li><b>MCAR (Missing Completely at Random):</b> Missingness is unrelated to any data.</li>
                            <li><b>MAR (Missing at Random):</b> Missingness can be explained by other observed variables.</li>
                            <li><b>MNAR (Missing Not at Random):</b> Missingness is related to the unobserved value itself (e.g., severely depressed patients are more likely to miss appointments).</li>
                        </ul>
                        <h4>Handling Strategies</h4>
                         <ul>
                            <li><b>Deletion:</b> Listwise or pairwise. Easy but can lose power and introduce bias.</li>
                            <li><b>Single Imputation:</b> Mean, median, or regression imputation. Can underestimate variance.</li>
                            <li><b>Multiple Imputation:</b> The gold standard. Creates multiple complete datasets to account for uncertainty.</li>
                        </ul>
                    </div>
                </div>
                <div class="column">
                    <div class="card">
                        <h3>Data Transformations for Normality</h3>
                        <p>If data is not normally distributed, we can sometimes transform it to meet test assumptions.</p>
                         <div class="mental-health-example">
                             Reaction time data is often positively skewed. A log transformation can often make it more symmetric and normal.
                         </div>
                         <div class="interactive-container">
                             <canvas id="transform-chart" height="150"></canvas>
                             <div class="optimizer-controls">
                                 <button onclick="showOriginalData()">Original Skewed Data</button>
                                 <button onclick="showLogTransformedData()">Apply Log Transform</button>
                             </div>
                         </div>
                    </div>
                </div>
             </div>
        </div>

        <!-- Slide 6: Bootstrap & Resampling Methods -->
        <div class="slide" id="slide-6">
            <h2 class="slide-title">6. Bootstrap & Resampling Methods</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Bootstrap Principle & Theory</h3>
                        <div class="definition">
                            <strong>Bootstrap Principle:</strong> Estimate sampling distribution by resampling with replacement from the observed sample. "Use the sample as a proxy for the population."
                        </div>
                        <p><strong>Theoretical Foundation:</strong></p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            FÃÇ‚Çô(x) = (1/n) Œ£·µ¢‚Çå‚ÇÅ‚Åø I(X·µ¢ ‚â§ x)<br>
                            Bootstrap: Resample from FÃÇ‚Çô to approximate F
                        </p>
                        
                        <p><strong>Bootstrap Algorithm:</strong></p>
                        <ol style="font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            <li>For b = 1 to B (e.g., B = 1000):</li>
                            <li>&nbsp;&nbsp;Draw sample X*·µ¶ of size n with replacement</li>
                            <li>&nbsp;&nbsp;Calculate statistic Œ∏ÃÇ*·µ¶ = T(X*·µ¶)</li>
                            <li>Use distribution of {Œ∏ÃÇ*‚ÇÅ, ..., Œ∏ÃÇ*·µ¶} for inference</li>
                        </ol>
                        
                        <p><strong>Bootstrap Confidence Intervals:</strong></p>
                        <ul>
                            <li><b>Percentile Method:</b> [Œ∏ÃÇ*‚ÇçŒ±/‚ÇÇ‚Çé, Œ∏ÃÇ*‚Çç‚ÇÅ‚ÇãŒ±/‚ÇÇ‚Çé]</li>
                            <li><b>Bias-Corrected:</b> Accounts for bias in Œ∏ÃÇ</li>
                            <li><b>Bootstrap-t:</b> Uses bootstrap estimate of SE</li>
                        </ul>
                    </div>
                    <div class="card">
                        <h3>Other Resampling Methods</h3>
                        <p><strong>Jackknife (Leave-One-Out):</strong></p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            Œ∏ÃÇ‚Çç·µ¢‚Çé = T(X‚ÇÅ, ..., X·µ¢‚Çã‚ÇÅ, X·µ¢‚Çä‚ÇÅ, ..., X‚Çô)<br>
                            Bias = (n-1)(Œ∏ÃÇÃÑ‚Çç‚Ä¢‚Çé - Œ∏ÃÇ)
                        </p>
                        
                        <p><strong>Permutation Tests:</strong></p>
                        <ul>
                            <li>Test H‚ÇÄ: F‚ÇÅ = F‚ÇÇ by permuting group labels</li>
                            <li>Exact p-values under null hypothesis</li>
                            <li>Robust to distributional assumptions</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            Bootstrap confidence intervals for median depression severity when data is heavily skewed and parametric CIs are unreliable.
                        </div>
                    </div>
                </div>
                <div class="column">
                    <div class="card">
                        <h3>Applications in Mental Health Research</h3>
                        <p><strong>When to Use Bootstrap:</strong></p>
                        <ul>
                            <li>Complex statistics (e.g., correlation ratios, mediation effects)</li>
                            <li>Non-normal data or small samples</li>
                            <li>Model selection uncertainty</li>
                            <li>Robust confidence intervals</li>
                        </ul>
                        
                        <p><strong>Bootstrap in Practice:</strong></p>
                        <pre style="font-size: 0.8em; background: var(--dark-card-bg); color: var(--text-color); padding: 15px; border-radius: 10px;"><code>
# Python Bootstrap Example
import numpy as np
from scipy import stats

def bootstrap_mean_ci(data, n_bootstrap=1000, alpha=0.05):
    bootstrap_means = []
    n = len(data)
    
    for _ in range(n_bootstrap):
        # Resample with replacement
        bootstrap_sample = np.random.choice(data, n, replace=True)
        bootstrap_means.append(np.mean(bootstrap_sample))
    
    # Calculate percentile CI
    lower = np.percentile(bootstrap_means, 100 * alpha/2)
    upper = np.percentile(bootstrap_means, 100 * (1 - alpha/2))
    
    return lower, upper, bootstrap_means

# Example: PHQ-9 scores
phq9_scores = [12, 15, 8, 22, 11, 9, 18, 6, 14, 20]
ci_lower, ci_upper, boot_means = bootstrap_mean_ci(phq9_scores)
print(f"95% CI for mean: [{ci_lower:.2f}, {ci_upper:.2f}]")
                        </code></pre>
                    </div>
                    <div class="card">
                        <h4>Interactive Bootstrap Demonstration</h4>
                        <div class="interactive-container">
                            <label>Bootstrap Samples: <input type="range" id="bootstrap-n" min="100" max="2000" step="100" value="1000"> <span id="bootstrap-n-val">1000</span></label>
                            <label>Statistic: 
                                <select id="bootstrap-stat">
                                    <option value="mean">Mean</option>
                                    <option value="median">Median</option>
                                    <option value="std">Standard Deviation</option>
                                </select>
                            </label>
                            <button onclick="runBootstrap()">Run Bootstrap</button>
                            <canvas id="bootstrap-chart" height="180"></canvas>
                            <div id="bootstrap-results"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 7: Hypothesis Testing Fundamentals -->
        <div class="slide" id="slide-7">
            <h2 class="slide-title">7. Hypothesis Testing: Types, Definitions & Power Analysis</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Types of Hypothesis Tests</h3>
                        <h4>Based on Direction:</h4>
                        <ul>
                            <li><b>Two-tailed (Non-directional):</b> H‚ÇÄ: Œº = Œº‚ÇÄ vs H‚ÇÅ: Œº ‚â† Œº‚ÇÄ</li>
                            <li><b>One-tailed (Directional):</b> 
                                <ul>
                                    <li>Right-tailed: H‚ÇÄ: Œº ‚â§ Œº‚ÇÄ vs H‚ÇÅ: Œº > Œº‚ÇÄ</li>
                                    <li>Left-tailed: H‚ÇÄ: Œº ‚â• Œº‚ÇÄ vs H‚ÇÅ: Œº < Œº‚ÇÄ</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <h4>Based on Parameters:</h4>
                        <ul>
                            <li><b>Tests of Location:</b> Mean, median (t-test, Mann-Whitney)</li>
                            <li><b>Tests of Variance:</b> Variability (F-test, Levene's test)</li>
                            <li><b>Tests of Association:</b> Correlation, independence (r, œá¬≤)</li>
                            <li><b>Tests of Distribution:</b> Normality (Shapiro-Wilk, K-S)</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            Testing if CBT reduces anxiety scores: H‚ÇÄ: Œº_after ‚â• Œº_before vs H‚ÇÅ: Œº_after < Œº_before (one-tailed)
                        </div>
                    </div>
                    <div class="card">
                        <h3>Error Types & Statistical Power</h3>
                        <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                            <tr style="background: var(--accent-color);">
                                <th style="border: 1px solid #ddd; padding: 8px;"></th>
                                <th style="border: 1px solid #ddd; padding: 8px;">H‚ÇÄ True</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">H‚ÇÅ True</th>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;"><b>Reject H‚ÇÄ</b></td>
                                <td style="border: 1px solid #ddd; padding: 8px; color: var(--danger-color);">Type I Error (Œ±)</td>
                                <td style="border: 1px solid #ddd; padding: 8px; color: var(--success-color);">Correct (Power = 1-Œ≤)</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;"><b>Fail to Reject H‚ÇÄ</b></td>
                                <td style="border: 1px solid #ddd; padding: 8px; color: var(--success-color);">Correct (1-Œ±)</td>
                                <td style="border: 1px solid #ddd; padding: 8px; color: var(--warning-color);">Type II Error (Œ≤)</td>
                            </tr>
                        </table>
                        
                        <div class="definition">
                            <strong>Statistical Power:</strong> P(Reject H‚ÇÄ | H‚ÇÅ is true) = 1 - Œ≤<br>
                            <strong>Conventional Levels:</strong> Œ± = 0.05, Power = 0.80
                        </div>
                        
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            Power = Œ¶((|Œº‚ÇÅ - Œº‚ÇÄ|/œÉ)‚àön - z_{Œ±/2})<br>
                            Effect Size: d = (Œº‚ÇÅ - Œº‚ÇÄ)/œÉ
                        </p>
                    </div>
                </div>
                <div class="column">
                    <div class="card">
                        <h3>Sample Size & Power Relationship</h3>
                        <p><strong>Key Factors Affecting Power:</strong></p>
                        <ul>
                            <li><b>Effect Size (d):</b> Larger effects ‚Üí Higher power</li>
                            <li><b>Sample Size (n):</b> More participants ‚Üí Higher power</li>
                            <li><b>Alpha Level (Œ±):</b> More liberal Œ± ‚Üí Higher power</li>
                            <li><b>Variability (œÉ):</b> Less noise ‚Üí Higher power</li>
                        </ul>
                        
                        <p><strong>Sample Size Calculation:</strong></p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            n = 2œÉ¬≤(z_{Œ±/2} + z_{Œ≤})¬≤ / (Œº‚ÇÅ - Œº‚ÇÄ)¬≤<br>
                            For two-sample t-test
                        </p>
                        
                        <p><strong>Cohen's Effect Size Guidelines:</strong></p>
                        <ul>
                            <li><b>Small:</b> d = 0.2 (PHQ-9 reduction: 2 points)</li>
                            <li><b>Medium:</b> d = 0.5 (PHQ-9 reduction: 5 points)</li>
                            <li><b>Large:</b> d = 0.8 (PHQ-9 reduction: 8 points)</li>
                        </ul>
                        
                        <div class="definition">
                            <strong>Why Pre-calculate Sample Size?</strong><br>
                            ‚Ä¢ Avoid underpowered studies (Type II errors)<br>
                            ‚Ä¢ Ensure ethical use of resources<br>
                            ‚Ä¢ Meet grant/publication requirements<br>
                            ‚Ä¢ Plan realistic timelines
                        </div>
                        
                        <div class="interactive-container">
                            <label>Effect Size (d): <input type="range" id="power-effect" min="0.1" max="1.5" step="0.1" value="0.5"> <span id="power-effect-val">0.5</span></label>
                            <label>Alpha Level: <input type="range" id="power-alpha" min="0.01" max="0.10" step="0.01" value="0.05"> <span id="power-alpha-val">0.05</span></label>
                            <label>Sample Size per Group: <input type="range" id="power-n" min="5" max="100" value="30"> <span id="power-n-val">30</span></label>
                            <button onclick="calculatePower()">Calculate Power</button>
                            <div id="power-results"></div>
                            <canvas id="power-chart" height="200"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 8: Non-parametric Tests -->
        <div class="slide" id="slide-8">
            <h2 class="slide-title">8. Non-parametric Tests: When Assumptions Fail</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>When to Use Non-parametric Tests</h3>
                        <div class="definition">
                            <strong>Definition:</strong> "Distribution-free" tests that do not rely on assumptions about the underlying population distribution. They often operate on ranks instead of raw data.
                        </div>
                        <h4>Use When:</h4>
                        <ul>
                            <li><b>Non-normal data:</b> Skewed distributions, outliers</li>
                            <li><b>Ordinal data:</b> Likert scales, ranked data</li>
                            <li><b>Small samples:</b> When normality can't be assessed</li>
                            <li><b>Robust analysis:</b> When you want distribution-free results</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            PHQ-9 scores are often skewed (floor effect), making non-parametric tests more appropriate than t-tests.
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Two-Sample Tests</h3>
                        <h4>Mann-Whitney U Test (Wilcoxon Rank-Sum)</h4>
                        <div class="definition">
                            <strong>Purpose:</strong> Compare medians of two independent groups (alternative to t-test)
                        </div>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            U‚ÇÅ = n‚ÇÅn‚ÇÇ + n‚ÇÅ(n‚ÇÅ+1)/2 - R‚ÇÅ<br>
                            U‚ÇÇ = n‚ÇÅn‚ÇÇ + n‚ÇÇ(n‚ÇÇ+1)/2 - R‚ÇÇ<br>
                            U = min(U‚ÇÅ, U‚ÇÇ)
                        </p>
                        <p>where R‚ÇÅ, R‚ÇÇ are sum of ranks for each group</p>
                        
                        <h4>Wilcoxon Signed-Rank Test</h4>
                        <p><strong>Purpose:</strong> Compare paired samples (alternative to paired t-test)</p>
                        <p>Uses signed ranks of differences between paired observations</p>
                    </div>
                </div>
                
                <div class="column">
                    <div class="card">
                        <h3>Multi-Group Tests</h3>
                        <h4>Kruskal-Wallis Test</h4>
                        <div class="definition">
                            <strong>Purpose:</strong> Compare medians across 3+ independent groups (alternative to ANOVA)
                        </div>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            H = 12/[N(N+1)] √ó Œ£·µ¢(R·µ¢¬≤/n·µ¢) - 3(N+1)<br>
                            where R·µ¢ = sum of ranks for group i
                        </p>
                        
                        <h4>Friedman Test</h4>
                        <p><strong>Purpose:</strong> Repeated measures with 3+ conditions (alternative to repeated measures ANOVA)</p>
                        
                        <div class="mental-health-example">
                            <strong>Example:</strong> Comparing depression scores across 4 different treatment conditions using Kruskal-Wallis.
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Correlation & Association</h3>
                        <h4>Spearman's Rank Correlation</h4>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            œÅ = 1 - 6Œ£d·µ¢¬≤/[n(n¬≤-1)]<br>
                            where d·µ¢ = difference in ranks
                        </p>
                        
                        <h4>Chi-Square Test of Independence</h4>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            œá¬≤ = Œ£(O·µ¢‚±º - E·µ¢‚±º)¬≤/E·µ¢‚±º<br>
                            E·µ¢‚±º = (row total √ó column total)/grand total
                        </p>
                        
                        <h4>Effect Sizes</h4>
                        <ul>
                            <li><b>Mann-Whitney:</b> r = Z/‚àöN</li>
                            <li><b>Kruskal-Wallis:</b> Œ∑¬≤ = (H-k+1)/(N-k)</li>
                            <li><b>Chi-square:</b> Cram√©r's V = ‚àö(œá¬≤/N√ómin(r-1,c-1))</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 9: Linear Regression -->
        <div class="slide" id="slide-9">
            <h2 class="slide-title">9. Linear Regression: Foundation of Predictive Modeling</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Simple Linear Regression</h3>
                        <div class="definition">
                            <strong>Model:</strong> y = Œ≤‚ÇÄ + Œ≤‚ÇÅx + Œµ, where Œµ ~ N(0, œÉ¬≤)
                        </div>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            Œ≤ÃÇ‚ÇÅ = Œ£(x·µ¢ - xÃÑ)(y·µ¢ - »≥) / Œ£(x·µ¢ - xÃÑ)¬≤<br>
                            Œ≤ÃÇ‚ÇÄ = »≥ - Œ≤ÃÇ‚ÇÅxÃÑ<br>
                            R¬≤ = 1 - SS·µ£‚Çë‚Çõ/SS‚Çú‚Çí‚Çú
                        </p>
                        <p><strong>Assumptions (LINE):</strong></p>
                        <ul>
                            <li><b>Linearity:</b> Relationship is linear</li>
                            <li><b>Independence:</b> Observations are independent</li>
                            <li><b>Normality:</b> Residuals are normally distributed</li>
                            <li><b>Equal variance:</b> Homoscedasticity</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            <strong>Example:</strong> Predicting depression severity (PHQ-9) from sleep hours: PHQ-9 = Œ≤‚ÇÄ + Œ≤‚ÇÅ(Sleep Hours) + Œµ
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Multiple Linear Regression</h3>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            y = Œ≤‚ÇÄ + Œ≤‚ÇÅx‚ÇÅ + Œ≤‚ÇÇx‚ÇÇ + ... + Œ≤‚Çöx‚Çö + Œµ<br>
                            Œ≤ÃÇ = (X'X)‚Åª¬πX'y<br>
                            Var(Œ≤ÃÇ) = œÉ¬≤(X'X)‚Åª¬π
                        </p>
                        <p><strong>Model Selection Criteria:</strong></p>
                        <ul>
                            <li><b>AIC:</b> -2ln(L) + 2k (penalizes complexity)</li>
                            <li><b>BIC:</b> -2ln(L) + k¬∑ln(n) (stronger penalty)</li>
                            <li><b>Adjusted R¬≤:</b> 1 - (1-R¬≤)(n-1)/(n-p-1)</li>
                        </ul>
                        
                        <div class="interactive-container">
                            <h4>Interactive Linear Regression</h4>
                            <label>Number of data points: <input type="range" id="linear-n" min="20" max="100" step="10" value="50"> <span id="linear-n-val">50</span></label>
                            <label>Noise level: <input type="range" id="linear-noise" min="0.1" max="2" step="0.1" value="0.5"> <span id="linear-noise-val">0.5</span></label>
                            <button onclick="generateLinearRegression()">Generate New Data</button>
                            <canvas id="linear-plot" height="300"></canvas>
                            <div id="linear-results"></div>
                        </div>
                    </div>
                </div>
                
                <div class="column">
                    <div class="card">
                        <h3>Residual Analysis & Diagnostics</h3>
                        <p><strong>Key Diagnostic Plots:</strong></p>
                        <ul>
                            <li><b>Residuals vs Fitted:</b> Check linearity and homoscedasticity</li>
                            <li><b>Q-Q Plot:</b> Check normality of residuals</li>
                            <li><b>Scale-Location:</b> Check homoscedasticity</li>
                            <li><b>Residuals vs Leverage:</b> Identify influential points</li>
                        </ul>
                        
                        <div class="definition">
                            <strong>Cook's Distance:</strong> Measures influence of each observation
                            <p style="text-align: center; font-family: monospace; margin: 10px 0;">
                                D·µ¢ = (r·µ¢¬≤/p) √ó (h·µ¢·µ¢/(1-h·µ¢·µ¢))
                            </p>
                        </div>
                        
                        <canvas id="residual-plot" height="200"></canvas>
                    </div>
                    
                    <div class="card">
                        <h3>Confidence & Prediction Intervals</h3>
                        <p><strong>Confidence Interval for Mean Response:</strong></p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            ≈∑ ¬± t_{Œ±/2,n-2} √ó SE(≈∑)
                        </p>
                        <p><strong>Prediction Interval for New Observation:</strong></p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            ≈∑ ¬± t_{Œ±/2,n-2} √ó SE(pred)
                        </p>
                        <p>where SE(pred) > SE(≈∑) due to additional uncertainty</p>
                        
                        <div class="mental-health-example">
                            <strong>Clinical Application:</strong> 95% prediction interval for new patient's PHQ-9 score gives clinically meaningful uncertainty bounds.
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Slide 10: Logistic Regression -->
        <div class="slide" id="slide-10">
            <h2 class="slide-title">10. Logistic Regression: Modeling Binary Outcomes</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Mathematical Foundation</h3>
                        <div class="definition">
                            <strong>Logistic Function:</strong> Models probability of binary outcome (0 or 1)
                        </div>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            P(Y=1|X) = 1/(1 + e^(-z))<br>
                            where z = Œ≤‚ÇÄ + Œ≤‚ÇÅX‚ÇÅ + Œ≤‚ÇÇX‚ÇÇ + ... + Œ≤‚ÇöX‚Çö<br><br>
                            Logit: ln(p/(1-p)) = Œ≤‚ÇÄ + Œ≤X<br>
                            Odds: p/(1-p) = e^(Œ≤‚ÇÄ + Œ≤X)<br>
                            Odds Ratio: e^Œ≤
                        </p>
                        
                        <h4>Key Characteristics</h4>
                        <ul>
                            <li><strong>S-shaped curve:</strong> Bounded between 0 and 1</li>
                            <li><strong>Log-odds:</strong> Linear in parameters</li>
                            <li><strong>No distributional assumptions:</strong> More robust than linear regression</li>
                            <li><strong>Maximum Likelihood Estimation:</strong> No closed-form solution</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            <strong>Example:</strong> Predicting depression diagnosis (0/1) from PHQ-9 score, sleep hours, and social support.
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Model Fitting & Interpretation</h3>
                        <p><strong>Maximum Likelihood Estimation:</strong></p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            L(Œ≤) = ‚àè·µ¢ p·µ¢ ∏‚Å±(1-p·µ¢)^(1-y·µ¢)<br>
                            Maximize: ln(L(Œ≤))
                        </p>
                        
                        <h4>Coefficient Interpretation</h4>
                        <ul>
                            <li><strong>Œ≤ coefficient:</strong> Change in log-odds per unit increase</li>
                            <li><strong>e^Œ≤:</strong> Odds ratio (multiplicative effect on odds)</li>
                            <li><strong>For probability:</strong> Need to calculate sigmoid function</li>
                        </ul>
                        
                        <div class="interactive-container">
                            <h4>Interactive Logistic Regression</h4>
                            <label>Sample Size: <input type="range" id="logistic-n" min="50" max="500" step="25" value="200"> <span id="logistic-n-val">200</span></label>
                            <label>Coefficient: <input type="range" id="logistic-coef" min="-3" max="3" step="0.1" value="1.5"> <span id="logistic-coef-val">1.5</span></label>
                            <button onclick="generateLogisticPlot()">Generate Logistic Regression</button>
                            <canvas id="logistic-plot" height="300"></canvas>
                            <div id="logistic-results"></div>
                        </div>
                    </div>
                </div>
                
                <div class="column">
                    <div class="card">
                        <h3>Model Evaluation</h3>
                        <h4>Classification Metrics</h4>
                        <ul>
                            <li><strong>Accuracy:</strong> (TP + TN) / (TP + TN + FP + FN)</li>
                            <li><strong>Sensitivity:</strong> TP / (TP + FN) [True Positive Rate]</li>
                            <li><strong>Specificity:</strong> TN / (TN + FP) [True Negative Rate]</li>
                            <li><strong>Precision:</strong> TP / (TP + FP) [Positive Predictive Value]</li>
                        </ul>
                        
                        <h4>Model Fit Measures</h4>
                        <ul>
                            <li><strong>AIC/BIC:</strong> Model comparison (lower is better)</li>
                            <li><strong>McFadden's R¬≤:</strong> Pseudo R-squared</li>
                            <li><strong>Hosmer-Lemeshow:</strong> Goodness of fit test</li>
                            <li><strong>C-statistic:</strong> Area under ROC curve</li>
                        </ul>
                        
                        <div class="interactive-container">
                            <h4>ROC Curve Analysis</h4>
                            <button onclick="generateROCPlot()" style="margin-bottom: 10px;">Generate ROC Curve</button>
                            <canvas id="roc-curve" height="300"></canvas>
                            <div id="roc-results"></div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Advanced Extensions</h3>
                        <h4>Multinomial Logistic Regression</h4>
                        <p>For outcomes with >2 categories (e.g., mild/moderate/severe depression)</p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            P(Y=j|X) = e^(Œ≤‚ÇÄ‚±º + Œ≤‚±ºX) / Œ£‚Çñ e^(Œ≤‚ÇÄ‚Çñ + Œ≤‚ÇñX)
                        </p>
                        
                        <h4>Ordinal Logistic Regression</h4>
                        <p>For ordered categories (e.g., Likert scales)</p>
                        
                        <h4>Regularized Logistic Regression</h4>
                        <ul>
                            <li><strong>Ridge (L2):</strong> Penalty = ŒªŒ£Œ≤·µ¢¬≤</li>
                            <li><strong>Lasso (L1):</strong> Penalty = ŒªŒ£|Œ≤·µ¢|</li>
                            <li><strong>Elastic Net:</strong> Combines L1 + L2</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            <strong>Clinical Application:</strong> Risk prediction models for suicide ideation, with regularization to handle many clinical variables.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 11: Machine Learning -->
        <div class="slide" id="slide-11">
            <h2 class="slide-title">11. Machine Learning: Advanced Predictive Models</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>What is Statistical Modeling?</h3>
                        <div class="definition">
                            <strong>Definition:</strong> The process of using data to create a simplified, mathematical representation of a real-world process. It helps us understand relationships and make predictions.
                        </div>
                        <h4>Supervised vs. Unsupervised Learning</h4>
                        <ul>
                           <li><b>Supervised:</b> The model learns from labeled data (input features and known outcomes). The goal is prediction.
                                <br><i>Example: Predicting treatment response (outcome) from baseline brain scans (features).</i>
                            </li>
                            <li><b>Unsupervised:</b> The model finds hidden patterns in unlabeled data. The goal is discovery.
                                <br><i>Example: Identifying novel subtypes of depression from patient symptom data.</i>
                            </li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h3>Support Vector Machines (SVM)</h3>
                        <div class="definition">
                            <strong>Concept:</strong> Find the optimal hyperplane that best separates data points of different classes with maximum margin.
                        </div>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            f(x) = sign(Œ£·µ¢ Œ±·µ¢y·µ¢K(x·µ¢, x) + b)<br>
                            where K(x·µ¢, x) is the kernel function
                        </p>
                        <h4>Kernel Functions</h4>
                        <ul>
                            <li><b>Linear:</b> K(x, x') = x¬∑x'</li>
                            <li><b>RBF (Gaussian):</b> K(x, x') = exp(-Œ≥||x-x'||¬≤)</li>
                            <li><b>Polynomial:</b> K(x, x') = (Œ≥x¬∑x' + r)·µà</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            <strong>Example:</strong> Classifying patients into responders/non-responders using neuroimaging features.
                        </div>
                    </div>
                </div>
                
                <div class="column">
                    <div class="card">
                        <h3>Random Forest</h3>
                        <div class="definition">
                            <strong>Ensemble Method:</strong> Builds many decision trees on different subsets of data and features, then averages predictions.
                        </div>
                        <p><strong>Algorithm:</strong></p>
                        <ol style="font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            <li>For b = 1 to B trees:</li>
                            <li>  Sample n observations with replacement</li>
                            <li>  At each split, sample m features randomly</li>
                            <li>  Build tree to maximum depth</li>
                            <li>Average predictions: ≈∑ = (1/B)Œ£·µ¶ ≈∑·µ¶</li>
                        </ol>
                        
                        <h4>Advantages</h4>
                        <ul>
                            <li><b>Reduced overfitting:</b> Averages out individual tree errors</li>
                            <li><b>Feature importance:</b> Measures contribution of each variable</li>
                            <li><b>Missing data:</b> Handles missing values naturally</li>
                            <li><b>Non-linear relationships:</b> Captures complex interactions</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            <strong>Application:</strong> Identifying key clinical predictors of treatment outcomes from EHR data.
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Neural Networks</h3>
                        <p><strong>Basic Architecture:</strong></p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            h = œÉ(Wx + b)<br>
                            œÉ(z) = 1/(1 + e‚Åª·∂ª) [sigmoid]<br>
                            œÉ(z) = max(0, z) [ReLU]
                        </p>
                        
                        <h4>Deep Learning Applications</h4>
                        <ul>
                            <li><b>CNNs:</b> Neuroimaging analysis (fMRI, structural MRI)</li>
                            <li><b>RNNs:</b> Sequential data (EEG, EMA time series)</li>
                            <li><b>Transformers:</b> Natural language processing (clinical notes)</li>
                            <li><b>Autoencoders:</b> Dimensionality reduction, anomaly detection</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            <strong>Example:</strong> Deep CNNs for automated depression detection from facial expressions in video data.
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Interactive Neural Network Simulation</h3>
                        <div class="interactive-container">
                            <h4>Supervised vs Unsupervised Learning Demo</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                                <label>Learning Type: 
                                    <select id="learning-type">
                                        <option value="supervised">Supervised</option>
                                        <option value="unsupervised">Unsupervised</option>
                                    </select>
                                </label>
                                <label>Network Complexity: <input type="range" id="nn-complexity" min="1" max="5" value="3"> <span id="nn-complexity-val">3</span></label>
                            </div>
                            <button onclick="runNeuralNetworkDemo()" style="margin-bottom: 15px;">Run Neural Network Demo</button>
                            <canvas id="neural-network-demo" height="250"></canvas>
                            <div id="neural-network-results"></div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>How Neural Networks Learn: Gradient Descent</h3>
                        <div class="definition">
                            <strong>Learning Process:</strong> Neural networks learn by iteratively adjusting weights to minimize prediction errors using gradient descent optimization.
                        </div>
                        
                        <h4>Forward Propagation</h4>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            z = Wx + b<br>
                            a = œÉ(z) = 1/(1 + e^(-z))<br>
                            ≈∑ = output layer activation
                        </p>
                        
                        <h4>Backward Propagation & Gradient Descent</h4>
                        <p style="text-align: center; font-family: monospace; background: rgba(255, 193, 7, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(255, 193, 7, 0.5);">
                            Loss: L = ¬Ω(y - ≈∑)¬≤<br>
                            ‚àÇL/‚àÇW = (≈∑ - y) √ó œÉ'(z) √ó x<br>
                            W_new = W_old - Œ± √ó ‚àÇL/‚àÇW<br>
                            where Œ± = learning rate
                        </p>
                        
                        <h4>Key Hyperparameters</h4>
                        <ul>
                            <li><b>Learning Rate (Œ±):</b> Step size for weight updates</li>
                            <li><b>Batch Size:</b> Number of samples per gradient update</li>
                            <li><b>Epochs:</b> Number of complete passes through data</li>
                            <li><b>Momentum:</b> Helps escape local minima</li>
                        </ul>
                        
                        <div class="interactive-container">
                            <h4>Gradient Descent Visualization</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                                <label>Learning Rate: <input type="range" id="grad-learning-rate" min="0.01" max="0.5" step="0.01" value="0.1"> <span id="grad-lr-val">0.1</span></label>
                                <label>Training Epochs: <input type="range" id="grad-epochs" min="10" max="100" step="10" value="50"> <span id="grad-epochs-val">50</span></label>
                            </div>
                            <button onclick="runGradientDescentDemo()" style="margin-bottom: 15px;">Run Gradient Descent Demo</button>
                            <canvas id="gradient-descent-demo" height="250"></canvas>
                            <div id="gradient-descent-results"></div>
                        </div>
                        
                        <div class="mental-health-example">
                            <strong>Clinical Example:</strong> Training a neural network to predict depression severity from multiple biomarkers requires careful tuning of learning rate to avoid overshooting optimal weights.
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Bayesian Machine Learning</h3>
                        <div class="definition">
                            <strong>Bayesian Approach:</strong> Treats model parameters as probability distributions rather than fixed values.
                        </div>
                        
                        <h4>Bayes' Theorem</h4>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            P(Œ∏|D) = P(D|Œ∏) √ó P(Œ∏) / P(D)<br>
                            Posterior = Likelihood √ó Prior / Evidence
                        </p>
                        
                        <h4>Key Concepts</h4>
                        <ul>
                            <li><b>Prior P(Œ∏):</b> What we believe before seeing data</li>
                            <li><b>Likelihood P(D|Œ∏):</b> How likely the data given parameters</li>
                            <li><b>Posterior P(Œ∏|D):</b> Updated beliefs after seeing data</li>
                            <li><b>Predictive Distribution:</b> P(new data | observed data)</li>
                        </ul>
                        
                        <h4>Applications in Mental Health</h4>
                        <ul>
                            <li><b>Uncertainty Quantification:</b> Critical for clinical decisions</li>
                            <li><b>Small Sample Learning:</b> Works well with limited clinical data</li>
                            <li><b>Incorporating Expertise:</b> Prior knowledge from clinicians</li>
                            <li><b>Personalized Models:</b> Individual-specific parameter distributions</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            <strong>Example:</strong> Bayesian neural networks for predicting treatment response with uncertainty estimates to guide clinical decisions.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 12: Time Series Analysis -->
        <div class="slide" id="slide-12">
            <h2 class="slide-title">12. Time Series Analysis: Dynamic Mental Health Data</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Time Series Fundamentals</h3>
                        <div class="definition">
                            <strong>Time Series:</strong> Data collected sequentially over time, where temporal order matters and observations may be correlated.
                        </div>
                        <h4>Key Components</h4>
                        <ul>
                            <li><b>Trend:</b> Long-term increase or decrease</li>
                            <li><b>Seasonality:</b> Regular, predictable patterns</li>
                            <li><b>Cyclical:</b> Longer-term fluctuations</li>
                            <li><b>Irregular:</b> Random fluctuations</li>
                        </ul>
                        
                        <h4>Stationarity</h4>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            Weak Stationarity:<br>
                            E[X‚Çú] = Œº (constant mean)<br>
                            Var(X‚Çú) = œÉ¬≤ (constant variance)<br>
                            Cov(X‚Çú, X‚Çú‚Çä‚Çï) = Œ≥(h) (depends only on lag h)
                        </p>
                        
                        <div class="mental-health-example">
                            <strong>Example:</strong> Daily mood ratings collected via smartphone apps show clear temporal dependencies.
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>ARIMA Models</h3>
                        <p><strong>AutoRegressive Integrated Moving Average ARIMA(p,d,q):</strong></p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            (1 - œÜ‚ÇÅB - œÜ‚ÇÇB¬≤ - ... - œÜ‚ÇöB·µñ)(1-B)·µàX‚Çú = <br>
                            (1 + Œ∏‚ÇÅB + Œ∏‚ÇÇB¬≤ + ... + Œ∏‚ÇëB·µ†)Œµ‚Çú
                        </p>
                        
                        <h4>Components</h4>
                        <ul>
                            <li><b>AR(p):</b> Autoregressive - depends on past values</li>
                            <li><b>I(d):</b> Integrated - differencing to achieve stationarity</li>
                            <li><b>MA(q):</b> Moving Average - depends on past errors</li>
                        </ul>
                        
                        <h4>Model Selection</h4>
                        <ul>
                            <li><b>AIC/BIC:</b> Information criteria for model comparison</li>
                            <li><b>ACF/PACF:</b> Autocorrelation functions for parameter identification</li>
                            <li><b>Ljung-Box:</b> Test for residual autocorrelation</li>
                        </ul>
                    </div>
                </div>
                
                <div class="column">
                    <div class="card">
                        <h3>Mental Health Applications</h3>
                        <h4>Ecological Momentary Assessment (EMA)</h4>
                        <ul>
                            <li><b>Mood tracking:</b> Multiple daily assessments</li>
                            <li><b>Stress monitoring:</b> Real-time psychological states</li>
                            <li><b>Behavioral patterns:</b> Sleep, activity, social interactions</li>
                            <li><b>Treatment monitoring:</b> Symptom changes over time</li>
                        </ul>
                        
                        <h4>Physiological Time Series</h4>
                        <ul>
                            <li><b>Heart Rate Variability:</b> Autonomic nervous system function</li>
                            <li><b>EEG:</b> Brain activity patterns</li>
                            <li><b>Actigraphy:</b> Activity/sleep data from wearables</li>
                            <li><b>Cortisol:</b> Stress hormone patterns</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            <strong>Clinical Application:</strong> Predicting depressive episodes from patterns in mood, sleep, and activity data.
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Advanced Time Series Methods</h3>
                        <h4>Vector Autoregression (VAR)</h4>
                        <p>For multivariate time series (e.g., mood + sleep + activity):</p>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            Y‚Çú = A‚ÇÅY‚Çú‚Çã‚ÇÅ + A‚ÇÇY‚Çú‚Çã‚ÇÇ + ... + A‚ÇöY‚Çú‚Çã‚Çö + Œµ‚Çú
                        </p>
                        
                        <h4>State Space Models</h4>
                        <ul>
                            <li><b>Hidden states:</b> Unobserved mood states</li>
                            <li><b>Kalman filtering:</b> Real-time state estimation</li>
                            <li><b>Dynamic modeling:</b> Time-varying parameters</li>
                        </ul>
                        
                        <h4>Machine Learning Approaches</h4>
                        <ul>
                            <li><b>LSTM:</b> Long Short-Term Memory networks</li>
                            <li><b>Prophet:</b> Facebook's time series forecasting</li>
                            <li><b>Dynamic Factor Models:</b> Dimensionality reduction</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 13: Signal Processing -->
        <div class="slide" id="slide-13">
            <h2 class="slide-title">13. Signal Processing: EEG & Neuroimaging Analysis</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Digital Signal Processing Fundamentals</h3>
                        <div class="definition">
                            <strong>Signal:</strong> A function that carries information about the behavior or attributes of some phenomenon (e.g., brain activity, heart rate).
                        </div>
                        <h4>Key Concepts</h4>
                        <ul>
                            <li><b>Sampling Rate (fs):</b> How often we measure the signal</li>
                            <li><b>Nyquist Frequency:</b> fs/2 - maximum detectable frequency</li>
                            <li><b>Aliasing:</b> Distortion when signal frequency > Nyquist frequency</li>
                            <li><b>Filtering:</b> Removing unwanted frequency components</li>
                        </ul>
                        
                        <h4>Fourier Transform</h4>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            X(f) = ‚à´‚Çã‚àû^‚àû x(t)e^(-j2œÄft) dt<br>
                            DFT: X[k] = Œ£‚Çô‚Çå‚ÇÄ^(N-1) x[n]e^(-j2œÄkn/N)
                        </p>
                        <p>Converts time domain signal to frequency domain</p>
                        
                        <div class="mental-health-example">
                            <strong>Example:</strong> Analyzing EEG to identify alpha waves (8-12 Hz) during eyes-closed resting state.
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>EEG Signal Processing Pipeline</h3>
                        <h4>Preprocessing Steps</h4>
                        <ol>
                            <li><b>Filtering:</b> Bandpass 0.5-40 Hz to remove drift and high-frequency noise</li>
                            <li><b>Artifact Removal:</b> ICA to remove eye blinks, muscle artifacts</li>
                            <li><b>Epoching:</b> Segment continuous data into trials</li>
                            <li><b>Baseline Correction:</b> Remove pre-stimulus activity</li>
                        </ol>
                        
                        <h4>Feature Extraction</h4>
                        <ul>
                            <li><b>Power Spectral Density:</b> Energy in frequency bands</li>
                            <li><b>Coherence:</b> Functional connectivity between regions</li>
                            <li><b>Event-Related Potentials:</b> Time-locked responses</li>
                            <li><b>Time-Frequency Analysis:</b> STFT, wavelets</li>
                        </ul>
                    </div>
                </div>
                
                <div class="column">
                    <div class="card">
                        <h3>EEG Frequency Bands</h3>
                        <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                            <tr style="background: var(--accent-color);">
                                <th style="border: 1px solid #ddd; padding: 8px;">Band</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Range (Hz)</th>
                                <th style="border: 1px solid #ddd; padding: 8px;">Associated with</th>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;"><b>Delta (Œ¥)</b></td>
                                <td style="border: 1px solid #ddd; padding: 8px;">0.5-4</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">Deep sleep, unconsciousness</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;"><b>Theta (Œ∏)</b></td>
                                <td style="border: 1px solid #ddd; padding: 8px;">4-8</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">Drowsiness, meditation</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;"><b>Alpha (Œ±)</b></td>
                                <td style="border: 1px solid #ddd; padding: 8px;">8-13</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">Relaxed awareness, eyes closed</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;"><b>Beta (Œ≤)</b></td>
                                <td style="border: 1px solid #ddd; padding: 8px;">13-30</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">Alert, focused thinking</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #ddd; padding: 8px;"><b>Gamma (Œ≥)</b></td>
                                <td style="border: 1px solid #ddd; padding: 8px;">30-100</td>
                                <td style="border: 1px solid #ddd; padding: 8px;">Binding, consciousness</td>
                            </tr>
                        </table>
                        
                        <h4>Clinical Applications</h4>
                        <ul>
                            <li><b>Depression:</b> Reduced alpha activity, increased beta activity</li>
                            <li><b>ADHD:</b> Increased theta/beta ratio</li>
                            <li><b>Anxiety:</b> Increased high-frequency activity</li>
                            <li><b>Alzheimer's:</b> Slowing of background rhythm</li>
                        </ul>
                    </div>
                    
                    <div class="card">
                        <h3>Advanced Signal Processing</h3>
                        <h4>Wavelet Analysis</h4>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            W(a,b) = 1/‚àöa ‚à´ x(t)œà*((t-b)/a) dt
                        </p>
                        <p>Provides time-frequency localization (better than STFT for non-stationary signals)</p>
                        
                        <h4>Independent Component Analysis (ICA)</h4>
                        <ul>
                            <li><b>Blind source separation:</b> Unmix overlapping signals</li>
                            <li><b>Artifact removal:</b> Eye blinks, muscle activity</li>
                            <li><b>Component analysis:</b> Identify brain networks</li>
                        </ul>
                        
                        <h4>Connectivity Analysis</h4>
                        <ul>
                            <li><b>Coherence:</b> Linear correlation in frequency domain</li>
                            <li><b>Phase-Locking Value:</b> Phase synchronization</li>
                            <li><b>Granger Causality:</b> Directed connectivity</li>
                            <li><b>Graph Theory:</b> Network properties (clustering, path length)</li>
                        </ul>
                        
                        <div class="mental-health-example">
                            <strong>Research Application:</strong> Studying altered brain connectivity in depression using EEG coherence analysis.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 14: Advanced Signal Processing & Network Analysis -->
        <div class="slide" id="slide-14">
            <h2 class="slide-title">14. Advanced Signal Processing & Network Analysis</h2>
            <div class="content">
                <div class="column">
                    <div class="card">
                        <h3>Fourier Analysis</h3>
                        <div class="definition">
                            <strong>Fourier Transform:</strong> Decomposes a signal into its frequency components.
                        </div>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            X(f) = ‚à´‚Çã‚àû^‚àû x(t)e^(-j2œÄft) dt<br>
                            DFT: X[k] = Œ£‚Çô‚Çå‚ÇÄ^(N-1) x[n]e^(-j2œÄkn/N)
                        </p>
                        
                        <h4>Applications in Neuroscience</h4>
                        <ul>
                            <li><b>Power Spectral Density:</b> Energy distribution across frequencies</li>
                            <li><b>Frequency Band Analysis:</b> Alpha (8-13 Hz), Beta (13-30 Hz)</li>
                            <li><b>Coherence:</b> Functional connectivity between brain regions</li>
                        </ul>
                        
                        <div class="interactive-container">
                            <h4>Interactive Fourier Analysis</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                                <label>Signal Frequency: <input type="range" id="fourier-freq" min="1" max="20" value="5"> <span id="fourier-freq-val">5</span> Hz</label>
                                <label>Noise Level: <input type="range" id="fourier-noise" min="0" max="2" step="0.1" value="0.5"> <span id="fourier-noise-val">0.5</span></label>
                            </div>
                            <button onclick="runFourierAnalysis()" style="margin-bottom: 15px;">Generate Signal & FFT</button>
                            <canvas id="time-domain-chart" height="120"></canvas>
                            <canvas id="frequency-domain-chart" height="120"></canvas>
                        </div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Short-Time Fourier Transform (STFT)</h3>
                        <div class="definition">
                            <strong>STFT:</strong> Applies Fourier transform to overlapping time windows to analyze non-stationary signals.
                        </div>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 10px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            STFT(œÑ,f) = ‚à´ x(t)w(t-œÑ)e^(-j2œÄft) dt
                        </p>
                        
                        <h4>Key Parameters</h4>
                        <ul>
                            <li><b>Window Size:</b> Time resolution vs frequency resolution trade-off</li>
                            <li><b>Overlap:</b> Typically 50-75% for smooth spectrograms</li>
                            <li><b>Window Function:</b> Hanning, Hamming, Blackman</li>
                        </ul>
                        
                        <div class="interactive-container">
                            <h4>STFT Simulation</h4>
                            <label>Window Size: <input type="range" id="stft-window" min="32" max="256" step="32" value="64"> <span id="stft-window-val">64</span></label>
                            <button onclick="runSTFTAnalysis()">Generate STFT Spectrogram</button>
                            <canvas id="stft-spectrogram" height="150"></canvas>
                        </div>
                    </div>
                </div>
                
                <div class="column">
                    <div class="card">
                        <h3>Morlet Wavelet Analysis</h3>
                        <div class="definition">
                            <strong>Morlet Wavelet:</strong> Complex wavelet that provides good time-frequency localization.
                        </div>
                        <p style="text-align: center; font-family: monospace; background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            œà(t) = œÄ^(-1/4) e^(jœâ‚ÇÄt) e^(-t¬≤/2)<br>
                            CWT(a,b) = 1/‚àöa ‚à´ x(t)œà*((t-b)/a) dt
                        </p>
                        
                        <h4>Advantages over STFT</h4>
                        <ul>
                            <li><b>Adaptive Resolution:</b> Good time resolution for high frequencies</li>
                            <li><b>Scale Invariance:</b> Natural for analyzing brain oscillations</li>
                            <li><b>Phase Information:</b> Preserves phase relationships</li>
                        </ul>
                        
                        <div class="interactive-container">
                            <h4>Wavelet Transform Simulation</h4>
                            <label>Central Frequency: <input type="range" id="wavelet-freq" min="5" max="25" value="10"> <span id="wavelet-freq-val">10</span> Hz</label>
                            <button onclick="runWaveletAnalysis()">Generate Wavelet Transform</button>
                            <canvas id="wavelet-scalogram" height="150"></canvas>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Network Connectivity Features</h3>
                        <h4>Functional Connectivity Measures</h4>
                        <ul>
                            <li><b>Coherence:</b> Linear correlation in frequency domain</li>
                            <li><b>Phase-Locking Value (PLV):</b> Phase synchronization</li>
                            <li><b>Mutual Information:</b> Non-linear dependencies</li>
                            <li><b>Transfer Entropy:</b> Directed information flow</li>
                        </ul>
                        
                        <h4>Graph Theory Metrics</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <b>Global Metrics:</b>
                                <ul>
                                    <li>Clustering Coefficient</li>
                                    <li>Path Length</li>
                                    <li>Small-worldness</li>
                                    <li>Global Efficiency</li>
                                </ul>
                            </div>
                            <div>
                                <b>Nodal Metrics:</b>
                                <ul>
                                    <li>Degree Centrality</li>
                                    <li>Betweenness Centrality</li>
                                    <li>Eigenvector Centrality</li>
                                    <li>Local Efficiency</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="mental-health-example">
                            <strong>Clinical Application:</strong> Altered network topology in depression - reduced global efficiency and increased clustering in default mode network.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slide 15: Conclusion & Comprehensive Resources -->
        <div class="slide" id="slide-15">
            <h2 class="slide-title">15. Conclusion & Comprehensive Resources</h2>
             <div class="content">
                 <div class="column">
                     <div class="card">
                         <h3>Summary of the Roadmap</h3>
                         <p>We've journeyed from the foundational language of probability to the cutting-edge of deep learning, all through the lens of mental health research.</p>
                         <ol>
                             <li><b>Statistical Foundations:</b> Master probability, descriptive statistics, and inference</li>
                             <li><b>Data Preparation:</b> Handle missing data, transformations, and preprocessing</li>
                             <li><b>Model Selection:</b> Choose appropriate tests and models based on assumptions</li>
                             <li><b>Advanced Methods:</b> Leverage ML, signal processing, and optimization</li>
                             <li><b>Validation & Ethics:</b> Ensure reproducible, interpretable, and clinically meaningful results</li>
                         </ol>
                         
                         <div class="definition">
                             <strong>Key Takeaway:</strong> The best analysis balances statistical rigor with clinical insight. Complex methods are tools, not ends in themselves.
                         </div>
                     </div>
                     <div class="card">
                         <h3>Next Steps in Your Journey</h3>
                         <ul>
                             <li><b>Practice:</b> Apply these methods to real mental health datasets</li>
                             <li><b>Collaborate:</b> Work with clinicians to ensure clinical relevance</li>
                             <li><b>Stay Current:</b> Follow developments in computational psychiatry</li>
                             <li><b>Ethics:</b> Consider privacy, bias, and fairness in all analyses</li>
                             <li><b>Reproducibility:</b> Document code, share data when possible</li>
                         </ul>
                     </div>
                 </div>
                 <div class="column">
                     <div class="card">
                         <h3>Essential References & Resources</h3>
                         <h4>üìö Core Textbooks</h4>
                         <ul class="reference-list">
                            <li><b>Statistics & ML:</b> "An Introduction to Statistical Learning" by James, Witten, Hastie, & Tibshirani (2021). Free PDF available.</li>
                            <li><b>Biostatistics:</b> "Fundamentals of Biostatistics" by Bernard Rosner (8th ed., 2015).</li>
                            <li><b>Bayesian Methods:</b> "Statistical Rethinking" by Richard McElreath (2020).</li>
                            <li><b>Causal Inference:</b> "Causal Inference: The Mixtape" by Scott Cunningham (2021).</li>
                         </ul>
                         
                         <h4>üß† Mental Health Applications</h4>
                         <ul class="reference-list">
                            <li>Dwyer, D. B., et al. (2018). "Machine learning approaches for clinical psychology and psychiatry." <i>Annual Review of Clinical Psychology</i>, 14, 91-118.</li>
                            <li>Chekroud, A. M., et al. (2016). "Cross-trial prediction of treatment outcome in depression." <i>The Lancet Psychiatry</i>, 3(3), 243-250.</li>
                            <li>Jacobucci, R., et al. (2019). "Machine learning and psychological research." <i>Current Directions in Psychological Science</i>, 28(2), 114-122.</li>
                            <li>Bzdok, D., & Meyer-Lindenberg, A. (2018). "Machine learning for precision psychiatry." <i>Nature Medicine</i>, 24(9), 1370-1381.</li>
                         </ul>
                         
                         <h4>üíª Programming Resources</h4>
                         <ul class="reference-list">
                            <li><b>Python:</b> scikit-learn, pandas, statsmodels, seaborn</li>
                            <li><b>R:</b> tidyverse, caret, ggplot2, lme4</li>
                            <li><b>Neuroimaging:</b> MNE-Python (EEG), nilearn (fMRI)</li>
                            <li><b>Tutorials:</b> Coursera, edX, Kaggle Learn</li>
                         </ul>
                         
                         <h4>üî¨ Key Journals</h4>
                         <ul class="reference-list">
                            <li><i>Psychological Medicine</i></li>
                            <li><i>Journal of Medical Internet Research - Mental Health</i></li>
                            <li><i>npj Digital Medicine</i></li>
                            <li><i>Translational Psychiatry</i></li>
                         </ul>
                     </div>
                 </div>
             </div>
        </div>

        <!-- Slide 16: Thank You & Contact Information -->
        <div class="slide" id="slide-16">
            <div class="content" style="max-width: 800px; margin: 0 auto;">
                <div style="text-align: center; margin-bottom: 50px; background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(138, 43, 226, 0.1)); padding: 40px; border-radius: 25px; box-shadow: 0 10px 30px rgba(0, 217, 255, 0.1);">
                    <h3 style="color: var(--accent-color); font-size: 2.5em; margin-bottom: 15px; font-weight: 300;">Dr. Ahmed Shaheen</h3>
                    <p style="font-size: 1.3em; color: var(--text-color); margin-bottom: 25px; line-height: 1.5;">
                        Thank you<br>
                        <strong style="background: linear-gradient(45deg, var(--accent-color), #8a2be2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">Biostatistics & Computational Modeling in Mental Health Research</strong>
                    </p>
                    <div style="display: inline-block; background: rgba(0, 217, 255, 0.2); padding: 15px 30px; border-radius: 50px; border: 2px solid var(--accent-color);">
                        <p style="font-size: 1.1em; margin: 0;">
                            <strong>üìß Contact:</strong> 
                            <a href="mailto:ahmeds1999haheen@gmail.com" style="color: var(--accent-color); text-decoration: none; font-weight: bold;">ahmeds1999haheen@gmail.com</a>
                        </p>
                    </div>
                </div>

                <!-- Professional Links Grid -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin: 30px 0;">
                    
                    <!-- Academic & Research -->
                    <div style="background: rgba(0, 217, 255, 0.05); padding: 20px; border-radius: 12px; border-left: 5px solid var(--accent-color);">
                        <h4 style="color: var(--accent-color); margin-bottom: 15px;">üìö Academic & Research</h4>
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <a href="https://scholar.google.com/citations?user=mRCNMuYAAAAJ&hl=en" target="_blank" style="display: block; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; text-decoration: none; color: var(--text-color); transition: all 0.3s ease;">
                                <strong style="color: var(--accent-color);">ÔøΩ Google Scholar</strong><br>
                                <span style="font-size: 0.9em; opacity: 0.8;">Publications & Citations</span>
                            </a>
                            <a href="https://www.researchgate.net/profile/Ahmed-Shaheen-6" target="_blank" style="display: block; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; text-decoration: none; color: var(--text-color); transition: all 0.3s ease;">
                                <strong style="color: var(--accent-color);">üìÑ ResearchGate</strong><br>
                                <span style="font-size: 0.9em; opacity: 0.8;">Academic Network & Papers</span>
                            </a>
                        </div>
                    </div>

                    <!-- Professional & Social -->
                    <div style="background: rgba(138, 43, 226, 0.05); padding: 20px; border-radius: 12px; border-left: 5px solid #8a2be2;">
                        <h4 style="color: #8a2be2; margin-bottom: 15px;">üíº Professional & Social</h4>
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <a href="https://github.com/doctor-shaheen" target="_blank" style="display: block; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; text-decoration: none; color: var(--text-color); transition: all 0.3s ease;">
                                <strong style="color: #8a2be2;">üíª GitHub</strong><br>
                                <span style="font-size: 0.9em; opacity: 0.8;">Open Source Projects & Code</span>
                            </a>
                            <a href="https://www.linkedin.com/in/neurointell/" target="_blank" style="display: block; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; text-decoration: none; color: var(--text-color); transition: all 0.3s ease;">
                                <strong style="color: #8a2be2;">üì± LinkedIn</strong><br>
                                <span style="font-size: 0.9em; opacity: 0.8;">Professional Network</span>
                            </a>
                            <a href="https://www.youtube.com/@DoctortScientist" target="_blank" style="display: block; padding: 12px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; text-decoration: none; color: var(--text-color); transition: all 0.3s ease;">
                                <strong style="color: #8a2be2;">üì∫ YouTube</strong><br>
                                <span style="font-size: 0.9em; opacity: 0.8;">Educational Content & Tutorials</span>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Key Resources -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin: 30px 0;">
                    <div style="background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(0, 217, 255, 0.1)); padding: 20px; border-radius: 15px; border: 2px solid rgba(138, 43, 226, 0.3); text-align: center;">
                        <strong style="color: var(--accent-color); font-size: 1.2em;">üè† Personal Website</strong><br>
                        <a href="https://www.ahmed-shaheen.site/" target="_blank" style="color: var(--accent-color); text-decoration: none; font-weight: bold; font-size: 1.1em;">ahmed-shaheen.site</a>
                        <p style="margin: 10px 0 0 0; font-size: 0.9em; color: var(--text-color); opacity: 0.8;">Complete portfolio & research overview</p>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, rgba(76, 175, 80, 0.1), rgba(255, 193, 7, 0.1)); padding: 20px; border-radius: 15px; border: 2px solid rgba(76, 175, 80, 0.3); text-align: center;">
                        <strong style="color: var(--accent-color); font-size: 1.2em;">üë®‚Äç‚öïÔ∏è My Professional Journey</strong><br>
                        <a href="https://doctor-shaheen.github.io/doctor-scientist" target="_blank" style="color: var(--accent-color); text-decoration: none; font-weight: bold; font-size: 1.1em;">From Medicine to Data Science</a>
                        <p style="margin: 10px 0 0 0; font-size: 0.9em; color: var(--text-color); opacity: 0.8;">Career story & achievements</p>
                    </div>
                </div>

                <!-- Call to Action -->
                <div style="text-align: center; padding: 30px; background: linear-gradient(45deg, rgba(0, 217, 255, 0.15), rgba(138, 43, 226, 0.15)); border-radius: 20px; border: 2px solid rgba(0, 217, 255, 0.3); box-shadow: 0 8px 25px rgba(0, 217, 255, 0.1); margin: 40px 0 20px 0;">
                    <p style="font-size: 1.5em; color: var(--accent-color); margin: 0 0 10px 0; font-weight: bold;">
                        üöÄ Let's Collaborate!
                    </p>
                    <p style="font-size: 1.1em; color: var(--text-color); margin: 0; opacity: 0.9;">
                        Advancing mental health research through data science & AI
                    </p>
                </div>

                <!-- Last Updated -->
                <div style="text-align: center; padding: 15px; background: rgba(255, 107, 107, 0.1); border-radius: 10px; margin: 20px 0;">
                    <p style="font-size: 0.9em; color: var(--text-color); margin: 0;">
                        <strong>Last Updated:</strong> July 2nd, 2025
                    </p>
                </div>
            </div>
        </div>


    </div>

    <div class="navigation">
        <button id="prev-btn" class="nav-btn" onclick="changeSlide(-1)">‚óÑ Prev</button>
        <span id="slide-counter">1 / 16</span>
        <button id="next-btn" class="nav-btn" onclick="changeSlide(1)">Next ‚ñ∫</button>
        <button id="overview-btn" class="nav-btn" onclick="toggleOverview()">Overview</button>
    </div>

    <div class="slide-overview" id="slide-overview">
        <h4>Slide Navigation</h4>
        <div class="slide-dots" id="slide-dots"></div>
    </div>

<script>
    // --- SLIDE NAVIGATION ---
    let currentSlide = 1;
    let totalSlides = 16; // Set this explicitly for now

    function showSlide(n) {
        const slides = document.querySelectorAll('.slide');
        slides.forEach(slide => slide.classList.remove('active'));
        const targetSlide = document.getElementById(`slide-${n}`);
        if (targetSlide) {
            targetSlide.classList.add('active');
        }
        
        document.getElementById('slide-counter').innerText = `${n} / ${totalSlides}`;
        document.getElementById('prev-btn').disabled = (n === 1);
        document.getElementById('next-btn').disabled = (n === totalSlides);
        
        updateSlideDots();
    }

    function changeSlide(direction) {
        try {
            console.log(`changeSlide called with direction: ${direction}`);
            console.log(`Current slide: ${currentSlide}, Total slides: ${totalSlides}`);
            
            currentSlide += direction;
            if (currentSlide < 1) currentSlide = 1;
            if (currentSlide > totalSlides) currentSlide = totalSlides;
            
            console.log(`New slide: ${currentSlide}`);
            showSlide(currentSlide);
        } catch (error) {
            console.error('Error in changeSlide:', error);
        }
    }
    
    function goToSlide(n) {
        currentSlide = n;
        showSlide(currentSlide);
    }
    
    function toggleOverview() {
        const overview = document.getElementById('slide-overview');
        overview.classList.toggle('visible');
    }
    
    function createSlideDots() {
        const dotsContainer = document.getElementById('slide-dots');
        const slideNames = [
            'Introduction & Overview',
            'The Roadmap',
            'Probability Foundations & Central Limit Theorem',
            'Descriptive Statistics: Understanding Your Data',
            'Inferential Statistics: From Sample to Population',
            'Bootstrap & Resampling Methods',
            'Hypothesis Testing: Types, Definitions & Power Analysis',
            'Non-parametric Tests: When Assumptions Fail',
            'Linear Regression: Foundation of Predictive Modeling',
            'Logistic Regression: Modeling Binary Outcomes',
            'Machine Learning: Advanced Predictive Models',
            'Time Series Analysis: Dynamic Mental Health Data',
            'Signal Processing: EEG & Neuroimaging Analysis',
            'Advanced Signal Processing & Network Analysis',
            'Conclusion & Comprehensive Resources',
            'Thank You & Contact'
        ];
        
        for (let i = 1; i <= totalSlides; i++) {
            const dot = document.createElement('div');
            dot.className = 'slide-dot';
            dot.setAttribute('data-slide', slideNames[i-1] || `Slide ${i}`);
            dot.addEventListener('click', () => {
                goToSlide(i);
                toggleOverview();
            });
            dotsContainer.appendChild(dot);
        }
    }
    
    function updateSlideDots() {
        const dots = document.querySelectorAll('.slide-dot');
        dots.forEach((dot, index) => {
            dot.classList.toggle('active', index + 1 === currentSlide);
        });
    }
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight') {
            changeSlide(1);
        } else if (e.key === 'ArrowLeft') {
            changeSlide(-1);
        } else if (e.key === 'Escape') {
            const overview = document.getElementById('slide-overview');
            overview.classList.remove('visible');
        }
    });

    // Initialize first slide
    document.addEventListener('DOMContentLoaded', () => {
        // Calculate total slides after DOM is loaded
        totalSlides = document.querySelectorAll('.slide').length;
        console.log(`Total slides found: ${totalSlides}`);
        
        // Check if navigation elements exist
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const slideCounter = document.getElementById('slide-counter');
        
        console.log('Navigation elements:', {
            prevBtn: !!prevBtn,
            nextBtn: !!nextBtn,
            slideCounter: !!slideCounter
        });
        
        createSlideDots();
        showSlide(currentSlide);
        console.log('Initial slide setup complete');
        
        mermaid.initialize({ 
            startOnLoad: true, 
            theme: 'dark',
            themeVariables: {
                primaryColor: '#1e2749',
                primaryTextColor: '#e1e8ed',
                primaryBorderColor: '#00d9ff',
                lineColor: '#00d9ff',
                textColor: '#e1e8ed',
                background: '#0a0e27',
                mainBkg: '#1e2749',
                secondBkg: '#141b2d'
            }
        });
        
        // Initialize all slider controls
        console.log('Initializing all interactive elements...');
        
        // Gradient descent controls
        const gradLrSlider = document.getElementById('grad-learning-rate');
        const gradEpochsSlider = document.getElementById('grad-epochs');
        
        if (gradLrSlider) {
            gradLrSlider.addEventListener('input', (e) => {
                document.getElementById('grad-lr-val').textContent = e.target.value;
            });
        }
        
        if (gradEpochsSlider) {
            gradEpochsSlider.addEventListener('input', (e) => {
                document.getElementById('grad-epochs-val').textContent = e.target.value;
            });
        }
        
        // Neural network complexity slider
        const complexitySlider = document.getElementById('nn-complexity');
        if (complexitySlider) {
            complexitySlider.addEventListener('input', (e) => {
                document.getElementById('nn-complexity-val').textContent = e.target.value;
            });
        }
        
        // Initialize logistic regression with delay to ensure Chart.js is ready
        setTimeout(function() {
            if (document.getElementById('logistic-n')) {
                try {
                    generateLogisticPlot();
                    console.log('Logistic regression initialized');
                } catch (error) {
                    console.error('Error initializing logistic regression:', error);
                }
            }
            
            // Initialize linear regression
            if (document.getElementById('linear-n')) {
                try {
                    generateLinearRegression();
                    console.log('Linear regression initialized');
                } catch (error) {
                    console.error('Error initializing linear regression:', error);
                }
            }
            
            // Initialize signal processing simulations
            if (document.getElementById('fourier-freq')) {
                try {
                    runFourierAnalysis();
                    console.log('Fourier analysis initialized');
                } catch (error) {
                    console.error('Error initializing fourier analysis:', error);
                }
            }
            if (document.getElementById('stft-window')) {
                try {
                    runSTFTAnalysis();
                    console.log('STFT analysis initialized');
                } catch (error) {
                    console.error('Error initializing STFT analysis:', error);
                }
            }
            if (document.getElementById('wavelet-freq')) {
                try {
                    runWaveletAnalysis();
                    console.log('Wavelet analysis initialized');
                } catch (error) {
                    console.error('Error initializing wavelet analysis:', error);
                }
            }
        }, 1000);
        
        console.log('All interactive elements initialized');
    });

    // --- INTERACTIVE SIMULATIONS ---

    // Slide 3: Probability
    let coinFlipChartInstance;
    function runCoinFlip() {
        const nFlips = parseInt(document.getElementById('flips').value);
        const flips = Array.from({length: nFlips}, () => Math.random());
        
        const probabilities = [];
        let heads = 0;
        for (let i = 0; i < nFlips; i++) {
            if (flips[i] < 0.5) {
                heads++;
            }
            probabilities.push(heads / (i + 1));
        }

        document.getElementById('coin-flip-output').innerText = `Observed Probability of Heads: ${probabilities[nFlips-1].toFixed(4)}`;
        
        if (coinFlipChartInstance) {
            coinFlipChartInstance.destroy();
        }
        
        const ctx = document.getElementById('coin-flip-chart').getContext('2d');
        coinFlipChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: Array.from({length: nFlips}, (_, i) => i + 1),
                datasets: [{
                    label: 'Observed P(Heads)',
                    data: probabilities,
                    borderColor: 'var(--secondary-color)',
                    borderWidth: 2,
                    pointRadius: 0
                }, {
                    label: 'True Probability (0.5)',
                    data: Array(nFlips).fill(0.5),
                    borderColor: 'var(--danger-color)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0
                }]
            },
            options: {
                scales: {
                    y: { min: 0, max: 1 },
                    x: { type: 'logarithmic', title: { display: true, text: 'Number of Flips' } }
                },
                animation: { duration: 0 }
            }
        });
    }
    document.getElementById('flips').addEventListener('input', (e) => {
        document.getElementById('flips-value').innerText = e.target.value;
    });

    function calculateBayes() {
        const prior = parseFloat(document.getElementById('prior').value);
        const sensitivity = parseFloat(document.getElementById('sensitivity').value);
        const specificity = parseFloat(document.getElementById('specificity').value);
        
        const p_pos_given_dep = sensitivity;
        const p_dep = prior;
        const p_pos_given_no_dep = 1 - specificity;
        const p_no_dep = 1 - prior;
        
        const p_pos = (p_pos_given_dep * p_dep) + (p_pos_given_no_dep * p_no_dep);
        const posterior = (p_pos_given_dep * p_dep) / p_pos;
        
        document.getElementById('bayes-output').innerText = `P(Depression | Positive Test) = ${(posterior * 100).toFixed(2)}%`;
    }

    // Slide 4: Descriptive Stats Chart
    const phq9_scores = [3,5,6,15,12,8,9,10,22,5,7,7,9,11,14,4,6,8,18,10,11,13,9,8,7];
    const bins = {};
    phq9_scores.forEach(score => {
        bins[score] = (bins[score] || 0) + 1;
    });
    const distCtx = document.getElementById('dist-chart').getContext('2d');
    new Chart(distCtx, {
        type: 'bar',
        data: {
            labels: Array.from({length: 28}, (_, i) => i), // PHQ-9 scores 0-27
            datasets: [{
                label: 'PHQ-9 Score Frequency',
                data: Array.from({length: 28}, (_, i) => bins[i] || 0),
                backgroundColor: 'var(--accent-color)',
            }]
        },
        options: {
             scales: { y: { beginAtZero: true } }
        }
    });

    // Slide 5: Data transformation functions
    let transformChart;
    const skewedData = Array.from({length: 500}, () => Math.pow(Math.random() * 5, 2));
    
    function plotHistogram(data, canvasId, title, color = 'var(--accent-color)') {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        
        // Create bins
        const bins = {};
        const minVal = Math.min(...data);
        const maxVal = Math.max(...data);
        const binSize = (maxVal - minVal) / 20;
        
        data.forEach(val => {
            const bin = Math.floor((val - minVal) / binSize);
            bins[bin] = (bins[bin] || 0) + 1;
        });
        
        const binLabels = Object.keys(bins).map(k => (minVal + parseInt(k) * binSize).toFixed(1));
        const binCounts = Object.values(bins);
        
        if (transformChart) transformChart.destroy();
        
        transformChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: binLabels,
                datasets: [{
                    label: title,
                    data: binCounts,
                    backgroundColor: color,
                    borderColor: 'var(--primary-color)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: title, color: 'var(--text-color)' },
                    legend: { labels: { color: 'var(--text-color)' } }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Value', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' }
                    },
                    y: { 
                        title: { display: true, text: 'Frequency', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' }
                    }
                }
            }
        });
    }
    
    function showOriginalData() {
        plotHistogram(skewedData, 'transform-chart', 'Original Skewed Data', 'var(--danger-color)');
    }
    
    function showLogTransformedData() {
        const logData = skewedData.map(d => Math.log(d + 1));
        plotHistogram(logData, 'transform-chart', 'Log-Transformed Data', 'var(--success-color)');
    }

    // Enhanced Logistic Regression Simulation
    let logisticRegressionChart;
    function runLogisticRegression() {
        const n = parseInt(document.getElementById('logistic-n').value);
        const trueIntercept = parseFloat(document.getElementById('logistic-intercept').value);
        const trueSlope = parseFloat(document.getElementById('logistic-slope').value);
        
        // Update display values
        document.getElementById('logistic-n-val').innerText = n;
        document.getElementById('logistic-intercept-val').innerText = trueIntercept;
        document.getElementById('logistic-slope-val').innerText = trueSlope;
        
        // Generate data: baseline PHQ-9 scores (x) vs treatment response (y)
        const xData = [];
        const yData = [];
        
        for (let i = 0; i < n; i++) {
            const x = 5 + Math.random() * 20; // PHQ-9 scores 5-25
            const logOdds = trueIntercept + trueSlope * x;
            const probability = 1 / (1 + Math.exp(-logOdds));
            const y = Math.random() < probability ? 1 : 0; // Binary response
            xData.push(x);
            yData.push(y);
        }
        
        // Simple logistic regression estimation using iterative approach
        let beta0 = 0, beta1 = 0;
        const learningRate = 0.01;
        const iterations = 1000;
        
        for (let iter = 0; iter < iterations; iter++) {
            let grad0 = 0, grad1 = 0;
            
            for (let i = 0; i < n; i++) {
                const logOdds = beta0 + beta1 * xData[i];
                const pred = 1 / (1 + Math.exp(-logOdds));
                const error = yData[i] - pred;
                
                grad0 += error;
                grad1 += error * xData[i];
            }
            
            beta0 += learningRate * grad0 / n;
            beta1 += learningRate * grad1 / n;
        }
        
        // Calculate model fit statistics
        let logLikelihood = 0;
        let correctPredictions = 0;
        
        for (let i = 0; i < n; i++) {
            const logOdds = beta0 + beta1 * xData[i];
            const pred = 1 / (1 + Math.exp(-logOdds));
            
            logLikelihood += yData[i] * Math.log(pred + 1e-10) + (1 - yData[i]) * Math.log(1 - pred + 1e-10);
            
            if ((pred > 0.5 && yData[i] === 1) || (pred <= 0.5 && yData[i] === 0)) {
                correctPredictions++;
            }
        }
        
        const accuracy = correctPredictions / n;
        const oddsRatio = Math.exp(beta1);
        
        // Display statistics
        document.getElementById('logistic-stats').innerHTML = `
            <strong>Logistic Regression Results:</strong><br>
            Estimated: log-odds = ${beta0.toFixed(3)} + ${beta1.toFixed(3)}√óPHQ9<br>
            True: log-odds = ${trueIntercept} + ${trueSlope}√óPHQ9<br>
            Odds Ratio = ${oddsRatio.toFixed(3)} | Accuracy = ${(accuracy * 100).toFixed(1)}%<br>
            Log-Likelihood = ${logLikelihood.toFixed(2)}
        `;
        
        // Create visualization
        const xRange = Array.from({length: 100}, (_, i) => 5 + (20 * i / 99));
        const yPredicted = xRange.map(x => 1 / (1 + Math.exp(-(beta0 + beta1 * x))));
        const yTrue = xRange.map(x => 1 / (1 + Math.exp(-(trueIntercept + trueSlope * x))));
        
        // Separate responders and non-responders
        const responders = xData.filter((x, i) => yData[i] === 1).map(x => ({x: x, y: 1}));
        const nonResponders = xData.filter((x, i) => yData[i] === 0).map(x => ({x: x, y: 0}));
        
        if (logisticRegressionChart) logisticRegressionChart.destroy();
        
        const ctx = document.getElementById('logistic-simulation-chart').getContext('2d');
        logisticRegressionChart = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Treatment Responders',
                    data: responders,
                    backgroundColor: 'var(--success-color)',
                    borderColor: 'var(--success-color)',
                    pointRadius: 4
                }, {
                    label: 'Non-Responders',
                    data: nonResponders,
                    backgroundColor: 'var(--danger-color)',
                    borderColor: 'var(--danger-color)',
                    pointRadius: 4
                }, {
                    label: 'Estimated Curve',
                    data: xRange.map((x, i) => ({x: x, y: yPredicted[i]})),
                    type: 'line',
                    borderColor: 'var(--primary-color)',
                    backgroundColor: 'transparent',
                    pointRadius: 0,
                    borderWidth: 3
                }, {
                    label: 'True Curve',
                    data: xRange.map((x, i) => ({x: x, y: yTrue[i]})),
                    type: 'line',
                    borderColor: 'var(--accent-color)',
                    backgroundColor: 'transparent',
                    pointRadius: 0,
                    borderWidth: 2,
                    borderDash: [5, 5]
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { 
                        display: true, 
                        text: 'Baseline PHQ-9 vs Treatment Response Probability',
                        color: 'var(--text-color)'
                    },
                    legend: { 
                        labels: { color: 'var(--text-color)' }
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Baseline PHQ-9 Score', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    },
                    y: { 
                        title: { display: true, text: 'Treatment Response Probability', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' },
                        grid: { color: 'rgba(255,255,255,0.1)' },
                        min: 0,
                        max: 1
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }
    
    // Add event listeners for logistic regression controls
    ['logistic-n', 'logistic-intercept', 'logistic-slope'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('input', () => {
                const valSpan = document.getElementById(id + '-val');
                if (valSpan) valSpan.innerText = element.value;
            });
        }
    });
    let regressionChart;
    function runLinearRegression() {
        const n = parseInt(document.getElementById('reg-n').value);
        const trueSlope = parseFloat(document.getElementById('reg-slope').value);
        const trueIntercept = parseFloat(document.getElementById('reg-intercept').value);
        const noiseStd = parseFloat(document.getElementById('reg-noise').value);
        
        // Update display values
        document.getElementById('reg-n-val').innerText = n;
        document.getElementById('reg-slope-val').innerText = trueSlope;
        document.getElementById('reg-intercept-val').innerText = trueIntercept;
        document.getElementById('reg-noise-val').innerText = noiseStd;
        
        // Generate data: sleep hours (x) vs PHQ-9 scores (y)
        const xData = [];
        const yData = [];
        
        for (let i = 0; i < n; i++) {
            const x = 4 + Math.random() * 8; // Sleep hours between 4-12
            const noise = noiseStd * (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() - 3); // Approximate normal
            const y = Math.max(0, Math.min(27, trueIntercept + trueSlope * x + noise)); // PHQ-9 bounded 0-27
            xData.push(x);
            yData.push(y);
        }
        
        // Calculate regression statistics
        const xMean = xData.reduce((a, b) => a + b) / n;
        const yMean = yData.reduce((a, b) => a + b) / n;
        
        let numerator = 0, denominatorX = 0, denominatorY = 0;
        for (let i = 0; i < n; i++) {
            const xDiff = xData[i] - xMean;
            const yDiff = yData[i] - yMean;
            numerator += xDiff * yDiff;
            denominatorX += xDiff * xDiff;
            denominatorY += yDiff * yDiff;
        }
        
        const estSlope = numerator / denominatorX;
        const estIntercept = yMean - estSlope * xMean;
        const correlation = numerator / Math.sqrt(denominatorX * denominatorY);
        const rSquared = correlation * correlation;
        
        // Calculate residuals and standard error
        let sumSquaredResiduals = 0;
        const residuals = [];
        for (let i = 0; i < n; i++) {
            const predicted = estIntercept + estSlope * xData[i];
            const residual = yData[i] - predicted;
            residuals.push(residual);
            sumSquaredResiduals += residual * residual;
        }
        
        const residualStdError = Math.sqrt(sumSquaredResiduals / (n - 2));
        const slopeStdError = residualStdError / Math.sqrt(denominatorX);
        const tStatistic = estSlope / slopeStdError;
        
        // Display statistics
        document.getElementById('regression-stats').innerHTML = `
            <strong>Regression Results:</strong><br>
            Estimated: ≈∑ = ${estIntercept.toFixed(2)} + ${estSlope.toFixed(2)}x<br>
            True: y = ${trueIntercept} + ${trueSlope}x<br>
            R¬≤ = ${rSquared.toFixed(3)} | SE(Œ≤‚ÇÅ) = ${slopeStdError.toFixed(3)} | t = ${tStatistic.toFixed(2)}<br>
            Correlation: r = ${correlation.toFixed(3)}
        `;
        
        // Create scatter plot with regression line
        const xRange = Array.from({length: 100}, (_, i) => 4 + (8 * i / 99));
        const yPredicted = xRange.map(x => estIntercept + estSlope * x);
        const yTrue = xRange.map(x => trueIntercept + trueSlope * x);
        
        if (regressionChart) regressionChart.destroy();
        
        const ctx = document.getElementById('regression-plot').getContext('2d');
        regressionChart = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Data Points',
                    data: xData.map((x, i) => ({x: x, y: yData[i]})),
                    backgroundColor: 'var(--accent-color)',
                    borderColor: 'var(--primary-color)',
                    pointRadius: 4
                }, {
                    label: 'Estimated Line',
                    data: xRange.map((x, i) => ({x: x, y: yPredicted[i]})),
                    type: 'line',
                    borderColor: 'var(--primary-color)',
                    backgroundColor: 'transparent',
                    pointRadius: 0,
                    borderWidth: 3
                }, {
                    label: 'True Line',
                    data: xRange.map((x, i) => ({x: x, y: yTrue[i]})),
                    type: 'line',
                    borderColor: 'var(--success-color)',
                    backgroundColor: 'transparent',
                    pointRadius: 0,
                    borderWidth: 2,
                    borderDash: [5, 5]
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { 
                        display: true, 
                        text: 'Sleep Hours vs Depression Severity (PHQ-9)',
                        color: 'var(--text-color)'
                    },
                    legend: { 
                        labels: { color: 'var(--text-color)' }
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Sleep Hours', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    },
                    y: { 
                        title: { display: true, text: 'PHQ-9 Score', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' },
                        grid: { color: 'rgba(255,255,255,0.1)' },
                        min: 0,
                        max: 27
                    }
                },
                interaction: {
                    intersect: false,
                    mode: 'index'
                }
            }
        });
    }
    
    // Add event listeners for regression controls
    ['reg-n', 'reg-slope', 'reg-intercept', 'reg-noise'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('input', () => {
                const valSpan = document.getElementById(id + '-val');
                if (valSpan) valSpan.innerText = element.value;
            });
        }
    });

    // Enhanced Logistic Regression Visualization
    function createLogisticChart() {
        const sigmoid = x => 1 / (1 + Math.exp(-x));
        const x_vals = Array.from({length: 201}, (_, i) => (i - 100) / 20);
        const y_vals = x_vals.map(sigmoid);
        
        const logisticCtx = document.getElementById('logistic-chart');
        if (!logisticCtx) return;
        
        new Chart(logisticCtx.getContext('2d'), {
            type: 'line',
            data: {
                labels: x_vals,
                datasets: [{
                    label: 'Logistic Function œÉ(x) = 1/(1+e^(-x))',
                    data: y_vals,
                    borderColor: 'var(--primary-color)',
                    backgroundColor: 'rgba(0, 217, 255, 0.1)',
                    tension: 0.4,
                    pointRadius: 0,
                    borderWidth: 3,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { 
                        display: true, 
                        text: 'Logistic Function for Binary Classification',
                        color: 'var(--text-color)'
                    },
                    legend: { 
                        labels: { color: 'var(--text-color)' }
                    }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Linear Predictor (Œ≤X)', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    },
                    y: { 
                        title: { display: true, text: 'Probability P(Y=1)', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' },
                        grid: { color: 'rgba(255,255,255,0.1)' },
                        min: 0,
                        max: 1
                    }
                }
            }
        });
    }
    let optAnimationId;
    const optCanvas = document.getElementById('optimizer-canvas');
    const optCtx = optCanvas.getContext('2d');
    const lossSurface = (x, y) => Math.sin(x * 0.5) * Math.cos(y * 0.5) * 2 + (x * x + y * y) * 0.05 + 2;
    const gradLossSurface = (x, y) => [0.25 * Math.cos(x*0.5)*Math.cos(y*0.5)*2 + 0.1*x, -0.25*Math.sin(x*0.5)*Math.sin(y*0.5)*2 + 0.1*y];

    function drawLossSurface() {
        const imageData = optCtx.createImageData(optCanvas.width, optCanvas.height);
        const data = imageData.data;
        let maxZ = -Infinity, minZ = Infinity;
        const zValues = [];
        for (let i = 0; i < optCanvas.width; i++) {
            for (let j = 0; j < optCanvas.height; j++) {
                const x = (i / optCanvas.width) * 10 - 5;
                const y = (j / optCanvas.height) * 6 - 3;
                const z = lossSurface(x, y);
                if (z > maxZ) maxZ = z;
                if (z < minZ) minZ = z;
                zValues.push(z);
            }
        }
        
        let k = 0;
        for (let i = 0; i < optCanvas.width; i++) {
            for (let j = 0; j < optCanvas.height; j++) {
                const z = zValues[k++];
                const shade = Math.floor(255 * (z - minZ) / (maxZ - minZ));
                const idx = (j * optCanvas.width + i) * 4;
                data[idx] = 233 + (shade/255 * (94-233)); // R
                data[idx + 1] = 216 + (shade/255 * (210-216)); // G
                data[idx + 2] = 166 + (shade/255 * (189-166)); // B
                data[idx + 3] = 255;
            }
        }
        optCtx.putImageData(imageData, 0, 0);
    }
    
    document.getElementById('start-opt-btn').addEventListener('click', () => {
        if (optAnimationId) cancelAnimationFrame(optAnimationId);
        
        let x = 4, y = -2.5;
        let vx = 0, vy = 0; // for momentum
        let m_x = 0, v_x = 0, m_y = 0, v_y = 0; // for adam
        let t = 0;
        const optimizer = document.getElementById('optimizer-select').value;
        const lr = optimizer === 'adam' ? 0.3 : 0.2;
        const beta1 = 0.9, beta2 = 0.999, epsilon = 1e-8;

        function animate() {
            drawLossSurface();
            
            const canvasX = (x + 5) / 10 * optCanvas.width;
            const canvasY = (y + 3) / 6 * optCanvas.height;
            optCtx.beginPath();
            optCtx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);
            optCtx.fillStyle = 'var(--danger-color)';
            optCtx.fill();

            const [gradX, gradY] = gradLossSurface(x, y);
            
            if (optimizer === 'sgd') {
                x -= lr * gradX;
                y -= lr * gradY;
            } else if (optimizer === 'momentum') {
                vx = 0.9 * vx - lr * gradX;
                vy = 0.9 * vy - lr * gradY;
                x += vx;
                y += vy;
            } else if (optimizer === 'adam') {
                t++;
                m_x = beta1 * m_x + (1 - beta1) * gradX;
                m_y = beta1 * m_y + (1 - beta1) * gradY;
                v_x = beta2 * v_x + (1 - beta2) * (gradX**2);
                v_y = beta2 * v_y + (1 - beta2) * (gradY**2);
                const m_hat_x = m_x / (1 - beta1**t);
                const m_hat_y = m_y / (1 - beta1**t);
                const v_hat_x = v_x / (1 - beta2**t);
                const v_hat_y = v_y / (1 - beta2**t);
                x -= lr * m_hat_x / (Math.sqrt(v_hat_x) + epsilon);
                y -= lr * m_hat_y / (Math.sqrt(v_hat_y) + epsilon);
            }
            
            if (t < 200) {
                optAnimationId = requestAnimationFrame(animate);
            }
        }
        animate();
    });
    
    // Slide 12: FFT
    const samplingRate = 100; // Hz
    const duration = 2; // seconds
    const numPoints = samplingRate * duration;
    const time = Array.from({length: numPoints}, (_, i) => i / samplingRate);
    // Signal: 3Hz sine wave + 10Hz sine wave + noise
    const signal = time.map(t => 1.5 * Math.sin(2 * Math.PI * 3 * t) + 1.0 * Math.sin(2 * Math.PI * 10 * t) + 0.5 * (Math.random() - 0.5));

    // Enhanced FFT calculation with proper implementation
    function fft(data, fs = 100) {
        const N = data.length;
        const freqs = Array.from({length: N / 2}, (_, i) => i * fs / N);
        const magnitudes = [];
        
        // Discrete Fourier Transform computation
        for (let k = 0; k < N / 2; k++) {
            let real = 0;
            let imag = 0;
            for (let n = 0; n < N; n++) {
                const angle = -2 * Math.PI * k * n / N;
                real += data[n] * Math.cos(angle);
                imag += data[n] * Math.sin(angle);
            }
            // Normalize and calculate magnitude
            const magnitude = Math.sqrt(real * real + imag * imag) * 2 / N;
            magnitudes.push(magnitude);
        }
        return {freqs, magnitudes};
    }
    
    const { freqs, magnitudes } = fft(signal);

    const fftCtx = document.getElementById('fft-chart').getContext('2d');
    new Chart(fftCtx, {
        type: 'line',
        data: {
            labels: freqs,
            datasets: [{
                label: 'Frequency Spectrum',
                data: magnitudes,
                borderColor: 'var(--primary-color)'
            }]
        },
        options: {
            plugins: { title: {display: true, text: 'Signal and its Fourier Transform'}},
            scales: {x: {title: {display: true, text: 'Frequency (Hz)'}}}
        }
    });

    // Central Limit Theorem Demonstration (Slide 3)
    function demonstrateCLT() {
        const n = parseInt(document.getElementById('clt-n').value);
        const distribution = document.getElementById('clt-dist').value;
        document.getElementById('clt-n-val').innerText = n;
        
        const numSamples = 1000;
        const sampleMeans = [];
        
        // Generate sampling distribution of means
        for (let i = 0; i < numSamples; i++) {
            let sample = [];
            
            // Generate sample based on selected distribution
            for (let j = 0; j < n; j++) {
                let value;
                switch(distribution) {
                    case 'uniform':
                        value = Math.random() * 10; // Uniform 0-10
                        break;
                    case 'exponential':
                        value = -Math.log(Math.random()) * 2; // Exponential with Œª=0.5
                        break;
                    case 'bimodal':
                        value = Math.random() < 0.5 ? 
                                2 + Math.random() * 2 : // 2-4
                                8 + Math.random() * 2;   // 8-10
                        break;
                }
                sample.push(value);
            }
            
            const sampleMean = sample.reduce((a, b) => a + b) / n;
            sampleMeans.push(sampleMean);
        }
        
        // Create histogram
        const bins = {};
        sampleMeans.forEach(mean => {
            const bin = Math.round(mean * 2) / 2; // 0.5 bins
            bins[bin] = (bins[bin] || 0) + 1;
        });
        
        const ctx = document.getElementById('clt-chart').getContext('2d');
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: Object.keys(bins).map(Number).sort((a, b) => a - b),
                datasets: [{
                    label: 'Sample Means Distribution',
                    data: Object.keys(bins).map(Number).sort((a, b) => a - b).map(key => bins[key]),
                    backgroundColor: 'var(--accent-color)',
                    borderColor: 'var(--primary-color)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { 
                        display: true, 
                        text: `Distribution of Sample Means (n=${n}, ${distribution})`,
                        color: 'var(--text-color)'
                    },
                    legend: { labels: { color: 'var(--text-color)' } }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Sample Mean', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' }
                    },
                    y: { 
                        title: { display: true, text: 'Frequency', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' }
                    }
                }
            }
        });
    }
    
    document.getElementById('clt-n').addEventListener('input', (e) => {
        document.getElementById('clt-n-val').innerText = e.target.value;
    });

    // Power Analysis Calculation (Slide 7)
    function calculatePower() {
        const effectSize = parseFloat(document.getElementById('power-effect').value);
        const alpha = parseFloat(document.getElementById('power-alpha').value);
        const n = parseInt(document.getElementById('power-n').value);
        
        document.getElementById('power-effect-val').innerText = effectSize;
        document.getElementById('power-alpha-val').innerText = alpha;
        document.getElementById('power-n-val').innerText = n;
        
        // Calculate power using normal approximation
        const zAlpha = Math.abs(normalInv(alpha / 2)); // Two-tailed
        const delta = effectSize * Math.sqrt(n / 2); // For two-sample t-test
        const power = 1 - normalCDF(zAlpha - delta) + normalCDF(-zAlpha - delta);
        
        // Calculate required sample size for 80% power
        const zBeta = Math.abs(normalInv(0.20)); // 80% power
        const requiredN = Math.ceil(2 * Math.pow((zAlpha + zBeta) / effectSize, 2));
        
        document.getElementById('power-results').innerHTML = `
            <strong>Power Analysis Results:</strong><br>
            Current Power: ${(power * 100).toFixed(1)}%<br>
            Sample Size for 80% Power: ${requiredN} per group<br>
            Effect Size Interpretation: ${effectSize < 0.3 ? 'Small' : effectSize < 0.7 ? 'Medium' : 'Large'}
        `;
        
        // Create power curve
        const sampleSizes = Array.from({length: 50}, (_, i) => (i + 1) * 2);
        const powerCurve = sampleSizes.map(size => {
            const delta = effectSize * Math.sqrt(size / 2);
            return 1 - normalCDF(zAlpha - delta) + normalCDF(-zAlpha - delta);
        });
        
        const ctx = document.getElementById('power-chart').getContext('2d');
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: sampleSizes,
                datasets: [{
                    label: 'Statistical Power',
                    data: powerCurve,
                    borderColor: 'var(--primary-color)',
                    backgroundColor: 'rgba(0, 217, 255, 0.1)',
                    pointRadius: 0,
                    borderWidth: 3,
                    fill: true
                }, {
                    label: '80% Power Line',
                    data: Array(sampleSizes.length).fill(0.8),
                    borderColor: 'var(--danger-color)',
                    borderDash: [5, 5],
                    pointRadius: 0,
                    borderWidth: 2
                }, {
                    label: 'Current Study',
                    data: sampleSizes.map((size, i) => size === n ? powerCurve[i] : null),
                    backgroundColor: 'var(--accent-color)',
                    pointRadius: 8,
                    showLine: false
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { 
                        display: true, 
                        text: `Power Curve (Effect Size = ${effectSize})`,
                        color: 'var(--text-color)'
                    },
                    legend: { labels: { color: 'var(--text-color)' } }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Sample Size per Group', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' }
                    },
                    y: { 
                        title: { display: true, text: 'Statistical Power', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' },
                        min: 0,
                        max: 1
                    }
                }
            }
        });
    }
    
    // Helper functions for normal distribution
    function normalCDF(x) {
        return 0.5 * (1 + erf(x / Math.sqrt(2)));
    }
    
    function normalInv(p) {
        // Approximate inverse normal using Beasley-Springer-Moro algorithm
        const a = [0, -3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
        const b = [0, -5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
        const c = [0, -7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
        const d = [0, 7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];
        
        if (p < 0.02425) {
            const q = Math.sqrt(-2 * Math.log(p));
            return (((((c[1]*q+c[2])*q+c[3])*q+c[4])*q+c[5])*q+c[6]) / ((((d[1]*q+d[2])*q+d[3])*q+d[4])*q+1);
        }
        if (p <= 0.97575) {
            const q = p - 0.5;
            const r = q * q;
            return (((((a[1]*r+a[2])*r+a[3])*r+a[4])*r+a[5])*r+a[6])*q / (((((b[1]*r+b[2])*r+b[3])*r+b[4])*r+b[5])*r+1);
        }
        const q = Math.sqrt(-2 * Math.log(1 - p));
        return -(((((c[1]*q+c[2])*q+c[3])*q+c[4])*q+c[5])*q+c[6]) / ((((d[1]*q+d[2])*q+d[3])*q+d[4])*q+1);
    }
    
    function erf(x) {
        // Approximation for error function
        const a1 =  0.254829592;
        const a2 = -0.284496736;
        const a3 =  1.421413741;
        const a4 = -1.453152027;
        const a5 =  1.061405429;
        const p  =  0.3275911;
        
        const sign = x < 0 ? -1 : 1;
        x = Math.abs(x);
        
        const t = 1.0 / (1.0 + p * x);
        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        
        return sign * y;
    }
    
    // Add event listeners for power analysis
    ['power-effect', 'power-alpha', 'power-n'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('input', () => {
                const valSpan = document.getElementById(id + '-val');
                if (valSpan) valSpan.innerText = element.value;
            });
        }
    });

    // Reset optimizer function
    function resetOptimizer() {
        if (optAnimationId) {
            cancelAnimationFrame(optAnimationId);
            optAnimationId = null;
        }
        drawLossSurface();
    }

    // Update learning rate display
    document.getElementById('opt-lr').addEventListener('input', (e) => {
        document.getElementById('opt-lr-val').innerText = e.target.value;
    });

    // MLE slider updates
    document.getElementById('sample-mean').addEventListener('input', (e) => {
        document.getElementById('mean-val').innerText = e.target.value;
    });
    document.getElementById('sample-std').addEventListener('input', (e) => {
        document.getElementById('std-val').innerText = e.target.value;
    });

    // FFT slider updates  
    document.getElementById('freq1').addEventListener('input', (e) => {
        document.getElementById('freq1-val').innerText = e.target.value;
    });
    document.getElementById('freq2').addEventListener('input', (e) => {
        document.getElementById('freq2-val').innerText = e.target.value;
    });
    document.getElementById('noise-level').addEventListener('input', (e) => {
        document.getElementById('noise-val').innerText = e.target.value;
    });

    // STFT slider update
    document.getElementById('stft-window').addEventListener('input', (e) => {
        document.getElementById('window-val').innerText = e.target.value;
    });

    // Wavelet slider update
    document.getElementById('wavelet-freq').addEventListener('input', (e) => {
        document.getElementById('wav-freq-val').innerText = e.target.value;
    });

    // NN parameter updates
    document.getElementById('nn-layers').addEventListener('input', (e) => {
        document.getElementById('nn-layers-val').innerText = e.target.value;
    });
    document.getElementById('nn-neurons').addEventListener('input', (e) => {
        document.getElementById('nn-neurons-val').innerText = e.target.value;
    });
    document.getElementById('nn-lr').addEventListener('input', (e) => {
        document.getElementById('nn-lr-val').innerText = e.target.value;
    });
    function runBootstrap() {
        const nBootstrap = parseInt(document.getElementById('bootstrap-n').value);
        const statistic = document.getElementById('bootstrap-stat') ? document.getElementById('bootstrap-stat').value : 'mean';
        document.getElementById('bootstrap-n-val').innerText = nBootstrap;
        
        // Original sample (simulated PHQ-9 scores with some skewness)
        const originalSample = [];
        for (let i = 0; i < 50; i++) {
            // Generate slightly skewed data (mixture of normal distributions)
            const x = Math.random() < 0.7 ? 
                      8 + 4 * (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() - 3) : // Normal component
                      18 + 3 * Math.random(); // High score component
            originalSample.push(Math.max(0, Math.min(27, x)));
        }
        
        // Calculate original statistic
        let originalStat;
        switch(statistic) {
            case 'mean':
                originalStat = originalSample.reduce((a, b) => a + b) / originalSample.length;
                break;
            case 'median':
                const sorted = [...originalSample].sort((a, b) => a - b);
                originalStat = sorted[Math.floor(sorted.length / 2)];
                break;
            case 'std':
                const mean = originalSample.reduce((a, b) => a + b) / originalSample.length;
                originalStat = Math.sqrt(originalSample.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / (originalSample.length - 1));
                break;
            default:
                originalStat = originalSample.reduce((a, b) => a + b) / originalSample.length;
        }
        
        // Bootstrap resampling
        const bootstrapStats = [];
        for (let b = 0; b < nBootstrap; b++) {
            const bootstrapSample = [];
            for (let i = 0; i < originalSample.length; i++) {
                const randomIndex = Math.floor(Math.random() * originalSample.length);
                bootstrapSample.push(originalSample[randomIndex]);
            }
            
            let bootstrapStat;
            switch(statistic) {
                case 'mean':
                    bootstrapStat = bootstrapSample.reduce((a, b) => a + b) / bootstrapSample.length;
                    break;
                case 'median':
                    const sorted = [...bootstrapSample].sort((a, b) => a - b);
                    bootstrapStat = sorted[Math.floor(sorted.length / 2)];
                    break;
                case 'std':
                    const mean = bootstrapSample.reduce((a, b) => a + b) / bootstrapSample.length;
                    bootstrapStat = Math.sqrt(bootstrapSample.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / (bootstrapSample.length - 1));
                    break;
                default:
                    bootstrapStat = bootstrapSample.reduce((a, b) => a + b) / bootstrapSample.length;
            }
            bootstrapStats.push(bootstrapStat);
        }
        
        // Calculate statistics
        bootstrapStats.sort((a, b) => a - b);
        const ci95Lower = bootstrapStats[Math.floor(0.025 * nBootstrap)];
        const ci95Upper = bootstrapStats[Math.floor(0.975 * nBootstrap)];
        const bootstrapSE = Math.sqrt(bootstrapStats.reduce((sum, stat) => sum + Math.pow(stat - originalStat, 2), 0) / nBootstrap);
        const bias = bootstrapStats.reduce((sum, stat) => sum + stat, 0) / nBootstrap - originalStat;
        
        // Create histogram of bootstrap statistics
        const bins = {};
        bootstrapStats.forEach(stat => {
            const bin = Math.round(stat * 4) / 4; // 0.25 bins
            bins[bin] = (bins[bin] || 0) + 1;
        });
        
        const ctx = document.getElementById('bootstrap-chart').getContext('2d');
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: Object.keys(bins).map(Number).sort((a, b) => a - b),
                datasets: [{
                    label: `Bootstrap ${statistic.charAt(0).toUpperCase() + statistic.slice(1)} Distribution`,
                    data: Object.keys(bins).map(Number).sort((a, b) => a - b).map(key => bins[key]),
                    backgroundColor: 'var(--accent-color)',
                    borderColor: 'var(--primary-color)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { 
                        display: true, 
                        text: `Bootstrap Distribution of ${statistic.toUpperCase()}`,
                        color: 'var(--text-color)'
                    },
                    legend: { labels: { color: 'var(--text-color)' } }
                },
                scales: {
                    x: { 
                        title: { display: true, text: `Bootstrap ${statistic}`, color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' }
                    },
                    y: { 
                        title: { display: true, text: 'Frequency', color: 'var(--text-color)' },
                        ticks: { color: 'var(--text-color)' }
                    }
                }
            }
        });
        
        const resultsElement = document.getElementById('bootstrap-results');
        if (resultsElement) {
            resultsElement.innerHTML = `
                <strong>Bootstrap Results:</strong><br>
                Original ${statistic}: ${originalStat.toFixed(3)}<br>
                Bootstrap SE: ${bootstrapSE.toFixed(3)}<br>
                Bias: ${bias.toFixed(3)}<br>
                95% CI: [${ci95Lower.toFixed(3)}, ${ci95Upper.toFixed(3)}]
            `;
        }
    }
    
    document.getElementById('bootstrap-n').addEventListener('input', (e) => {
        document.getElementById('bootstrap-n-val').innerText = e.target.value;
    });

    // --- NEW INTERACTIVE FUNCTIONS ---

    // Slide 9: MLE Simulation
    let mleChart;
    function updateMLE() {
        const sampleMean = parseFloat(document.getElementById('sample-mean').value);
        const sampleStd = parseFloat(document.getElementById('sample-std').value);
        
        document.getElementById('mean-val').innerText = sampleMean;
        document.getElementById('std-val').innerText = sampleStd;
        
        // Generate sample data
        const data = [];
        for (let i = 0; i < 100; i++) {
            data.push(sampleMean + sampleStd * (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() - 3));
        }
        
        // Create histogram
        const bins = {};
        data.forEach(d => {
            const bin = Math.round(d * 2) / 2; // 0.5 bins
            bins[bin] = (bins[bin] || 0) + 1;
        });
        
        const xValues = Object.keys(bins).map(Number).sort((a, b) => a - b);
        const yValues = xValues.map(x => bins[x]);
        
        if (mleChart) mleChart.destroy();
        
        const ctx = document.getElementById('mle-chart').getContext('2d');
        mleChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: xValues,
                datasets: [{
                    label: 'Sample Data',
                    data: yValues,
                    backgroundColor: 'var(--accent-color)'
                }]
            },
            options: {
                scales: {
                    x: { title: { display: true, text: 'Value' } },
                    y: { title: { display: true, text: 'Frequency' } }
                }
            }
        });
    }

    // Slide 10: t-test Simulation
    function runTTest() {
        const n = parseInt(document.getElementById('t-sample-size').value);
        const trueMean = parseFloat(document.getElementById('t-true-mean').value);
        const nullMean = parseFloat(document.getElementById('t-null-mean').value);
        
        document.getElementById('t-n-val').innerText = n;
        document.getElementById('t-mean-val').innerText = trueMean;
        
        // Generate sample data
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push(trueMean + 2 * (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() - 3));
        }
        
        const sampleMean = data.reduce((a, b) => a + b) / n;
        const sampleStd = Math.sqrt(data.reduce((sum, x) => sum + Math.pow(x - sampleMean, 2), 0) / (n - 1));
        const standardError = sampleStd / Math.sqrt(n);
        const tStat = (sampleMean - nullMean) / standardError;
        const df = n - 1;
        
        // Approximate p-value calculation (two-tailed)
        const pValue = 2 * (1 - tDistribution(Math.abs(tStat), df));
        
        document.getElementById('t-test-results').innerHTML = `
            <p><b>Sample Mean:</b> ${sampleMean.toFixed(3)}</p>
            <p><b>t-statistic:</b> ${tStat.toFixed(3)}</p>
            <p><b>p-value:</b> ${pValue.toFixed(4)}</p>
            <p><b>Result:</b> ${pValue < 0.05 ? 'Reject H‚ÇÄ' : 'Fail to reject H‚ÇÄ'}</p>
        `;
        
        // Draw t-distribution
        const ctx = document.getElementById('t-distribution-chart').getContext('2d');
        const x = [];
        const y = [];
        for (let i = -4; i <= 4; i += 0.1) {
            x.push(i);
            y.push(tDistributionPDF(i, df));
        }
        
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: x,
                datasets: [{
                    label: 't-distribution',
                    data: y,
                    borderColor: 'var(--primary-color)',
                    pointRadius: 0
                }, {
                    label: 'Observed t-stat',
                    data: x.map(val => val === Math.round(tStat * 10) / 10 ? Math.max(...y) : null),
                    backgroundColor: 'var(--danger-color)',
                    pointRadius: 5,
                    showLine: false
                }]
            }
        });
    }
    
    document.getElementById('t-sample-size').addEventListener('input', (e) => {
        document.getElementById('t-n-val').innerText = e.target.value;
    });
    document.getElementById('t-true-mean').addEventListener('input', (e) => {
        document.getElementById('t-mean-val').innerText = e.target.value;
    });

    // Helper functions for t-distribution
    function tDistributionPDF(x, df) {
        const gamma1 = Math.exp(logGamma((df + 1) / 2));
        const gamma2 = Math.exp(logGamma(df / 2));
        return gamma1 / (gamma2 * Math.sqrt(df * Math.PI)) * Math.pow(1 + x * x / df, -(df + 1) / 2);
    }
    
    function tDistribution(t, df) {
        // Approximate CDF using normal approximation for large df
        if (df > 30) return 0.5 + 0.5 * Math.sign(t) * Math.sqrt(1 - Math.exp(-2 * t * t / Math.PI));
        return 0.5; // Simplified for demo
    }
    
    function logGamma(x) {
        // Stirling's approximation
        return (x - 0.5) * Math.log(x) - x + 0.5 * Math.log(2 * Math.PI);
    }

    // Confidence Interval Simulation
    function simulateCI() {
        const ctx = document.getElementById('ci-simulation-chart').getContext('2d');
        const trueMean = 10;
        const trueStd = 2;
        const n = 20;
        let coverageCount = 0;
        
        const results = [];
        for (let i = 0; i < 100; i++) {
            // Generate sample
            const sample = [];
            for (let j = 0; j < n; j++) {
                sample.push(trueMean + trueStd * (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() - 3));
            }
            
            const sampleMean = sample.reduce((a, b) => a + b) / n;
            const sampleStd = Math.sqrt(sample.reduce((sum, x) => sum + Math.pow(x - sampleMean, 2), 0) / (n - 1));
            const margin = 2.093 * sampleStd / Math.sqrt(n); // t-critical for df=19, alpha=0.05
            
            const lower = sampleMean - margin;
            const upper = sampleMean + margin;
            const covers = (lower <= trueMean && trueMean <= upper);
            
            if (covers) coverageCount++;
            
            results.push({
                index: i,
                lower: lower,
                upper: upper,
                covers: covers
            });
        }
        
        new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'CI Lower',
                    data: results.map(r => ({x: r.index, y: r.lower})),
                    backgroundColor: r => r.covers ? 'var(--secondary-color)' : 'var(--danger-color)',
                    pointRadius: 2
                }, {
                    label: 'CI Upper', 
                    data: results.map(r => ({x: r.index, y: r.upper})),
                    backgroundColor: r => r.covers ? 'var(--secondary-color)' : 'var(--danger-color)',
                    pointRadius: 2
                }, {
                    label: 'True Mean',
                    data: [{x: 0, y: trueMean}, {x: 99, y: trueMean}],
                    borderColor: 'var(--danger-color)',
                    borderWidth: 3,
                    pointRadius: 0,
                    type: 'line'
                }]
            }
        });
        
        document.getElementById('ci-coverage').innerText = `Coverage: ${coverageCount}/100 (${coverageCount}%)`;
    }

    // Slide 11: Bias-Variance Tradeoff
    let biasVarianceChart;
    function updateBiasVariance() {
        const complexity = parseInt(document.getElementById('complexity-slider').value);
        document.getElementById('complexity-val').innerText = complexity;
        
        // Simulate bias-variance tradeoff
        const x = Array.from({length: 20}, (_, i) => i);
        const bias = x.map(i => Math.pow(Math.E, -i/3) * 5); // Exponential decay
        const variance = x.map(i => Math.pow(i/10, 2)); // Quadratic growth
        const totalError = x.map((_, i) => bias[i] + variance[i] + 1); // +1 for irreducible error
        
        // Mark current complexity
        const currentPoint = complexity - 1;
        
        if (biasVarianceChart) biasVarianceChart.destroy();
        
        const ctx = document.getElementById('bias-variance-chart').getContext('2d');
        biasVarianceChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: x.map(i => i + 1),
                datasets: [{
                    label: 'Bias¬≤',
                    data: bias,
                    borderColor: 'var(--primary-color)',
                    pointRadius: 0
                }, {
                    label: 'Variance',
                    data: variance,
                    borderColor: 'var(--secondary-color)',
                    pointRadius: 0
                }, {
                    label: 'Total Error',
                    data: totalError,
                    borderColor: 'var(--danger-color)',
                    pointRadius: 0
                }, {
                    label: 'Current Model',
                    data: x.map((_, i) => i === currentPoint ? totalError[i] : null),
                    backgroundColor: 'var(--accent-color)',
                    pointRadius: 8,
                    showLine: false
                }]
            },
            options: {
                scales: {
                    x: { title: { display: true, text: 'Model Complexity' } },
                    y: { title: { display: true, text: 'Error' } }
                }
            }
        });
    }
    
    document.getElementById('complexity-slider').addEventListener('input', updateBiasVariance);

    // Slide 12: Neural Network
    let nnData = {
        weights: [],
        biases: [],
        activations: [],
        loss: [],
        accuracy: []
    };
    
    function initializeNN() {
        const layers = parseInt(document.getElementById('nn-layers').value);
        const neurons = parseInt(document.getElementById('nn-neurons').value);
        
        document.getElementById('nn-layers-val').innerText = layers;
        document.getElementById('nn-neurons-val').innerText = neurons;
        
        // Initialize random weights and biases
        nnData.weights = [];
        nnData.biases = [];
        
        // Input layer (2 inputs) to first hidden layer
        nnData.weights.push(Array.from({length: neurons}, () => 
            Array.from({length: 2}, () => Math.random() * 2 - 1)));
        nnData.biases.push(Array.from({length: neurons}, () => Math.random() * 2 - 1));
        
        // Hidden layers
        for (let i = 1; i < layers; i++) {
            nnData.weights.push(Array.from({length: neurons}, () => 
                Array.from({length: neurons}, () => Math.random() * 2 - 1)));
            nnData.biases.push(Array.from({length: neurons}, () => Math.random() * 2 - 1));
        }
        
        // Output layer (1 output)
        nnData.weights.push(Array.from({length: 1}, () => 
            Array.from({length: neurons}, () => Math.random() * 2 - 1)));
        nnData.biases.push([Math.random() * 2 - 1]);
        
        nnData.loss = [];
        nnData.accuracy = [];
        
        drawNeuralNetwork();
        updateTrainingProgress();
    }
    
    function drawNeuralNetwork() {
        const canvas = document.getElementById('neural-network-viz');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const layers = parseInt(document.getElementById('nn-layers').value) + 2; // +input +output
        const neurons = parseInt(document.getElementById('nn-neurons').value);
        
        const layerSpacing = canvas.width / (layers + 1);
        const neuronSpacing = canvas.height / (neurons + 1);
        
        // Draw neurons
        for (let layer = 0; layer < layers; layer++) {
            const x = layerSpacing * (layer + 1);
            const neuronsInLayer = layer === 0 ? 2 : (layer === layers - 1 ? 1 : neurons);
            
            for (let neuron = 0; neuron < neuronsInLayer; neuron++) {
                const y = canvas.height / 2 + (neuron - (neuronsInLayer - 1) / 2) * neuronSpacing / 2;
                
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, 2 * Math.PI);
                ctx.fillStyle = layer === 0 ? 'var(--accent-color)' : 
                               layer === layers - 1 ? 'var(--danger-color)' : 'var(--secondary-color)';
                ctx.fill();
                ctx.strokeStyle = 'var(--primary-color)';
                ctx.stroke();
            }
        }
        
        // Draw connections (simplified)
        ctx.strokeStyle = 'var(--primary-color)';
        ctx.globalAlpha = 0.3;
        for (let layer = 0; layer < layers - 1; layer++) {
            const x1 = layerSpacing * (layer + 1);
            const x2 = layerSpacing * (layer + 2);
            const neurons1 = layer === 0 ? 2 : neurons;
            const neurons2 = layer === layers - 2 ? 1 : neurons;
            
            for (let i = 0; i < neurons1; i++) {
                for (let j = 0; j < neurons2; j++) {
                    const y1 = canvas.height / 2 + (i - (neurons1 - 1) / 2) * neuronSpacing / 2;
                    const y2 = canvas.height / 2 + (j - (neurons2 - 1) / 2) * neuronSpacing / 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }
        }
        ctx.globalAlpha = 1;
    }
    
    function trainStep() {
        // Simulate one training step
        const currentLoss = Math.max(0.1, (nnData.loss[nnData.loss.length - 1] || 1) * (0.98 + Math.random() * 0.04));
        const currentAcc = Math.min(0.95, (nnData.accuracy[nnData.accuracy.length - 1] || 0.5) + Math.random() * 0.02);
        
        nnData.loss.push(currentLoss);
        nnData.accuracy.push(currentAcc);
        
        updateTrainingProgress();
        updateNNMetrics();
    }
    
    function trainNetwork() {
        for (let i = 0; i < 100; i++) {
            trainStep();
        }
    }
    
    function updateTrainingProgress() {
        const ctx = document.getElementById('training-progress-chart').getContext('2d');
        
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: Array.from({length: nnData.loss.length}, (_, i) => i + 1),
                datasets: [{
                    label: 'Loss',
                    data: nnData.loss,
                    borderColor: 'var(--danger-color)',
                    yAxisID: 'y'
                }, {
                    label: 'Accuracy',
                    data: nnData.accuracy,
                    borderColor: 'var(--secondary-color)',
                    yAxisID: 'y1'
                }]
            },
            options: {
                scales: {
                    y: { type: 'linear', display: true, position: 'left' },
                    y1: { type: 'linear', display: true, position: 'right', grid: { drawOnChartArea: false } }
                }
            }
        });
    }
    
    function updateNNMetrics() {
        const lastLoss = nnData.loss[nnData.loss.length - 1] || 0;
        const lastAcc = nnData.accuracy[nnData.accuracy.length - 1] || 0;
        document.getElementById('nn-metrics').innerHTML = `
            <p><b>Current Loss:</b> ${lastLoss.toFixed(4)}</p>
            <p><b>Current Accuracy:</b> ${(lastAcc * 100).toFixed(1)}%</p>
            <p><b>Training Steps:</b> ${nnData.loss.length}</p>
        `;
    }
    
    document.getElementById('nn-layers').addEventListener('input', (e) => {
        document.getElementById('nn-layers-val').innerText = e.target.value;
    });
    document.getElementById('nn-neurons').addEventListener('input', (e) => {
        document.getElementById('nn-neurons-val').innerText = e.target.value;
    });
    document.getElementById('nn-lr').addEventListener('input', (e) => {
        document.getElementById('nn-lr-val').innerText = e.target.value;
    });
    
    // Activation Functions
    function showActivation(type) {
        const x = Array.from({length: 201}, (_, i) => (i - 100) / 20);
        let y;
        
        switch(type) {
            case 'sigmoid':
                y = x.map(val => 1 / (1 + Math.exp(-val)));
                break;
            case 'tanh':
                y = x.map(val => Math.tanh(val));
                break;
            case 'relu':
                y = x.map(val => Math.max(0, val));
                break;
            case 'leaky_relu':
                y = x.map(val => val > 0 ? val : 0.01 * val);
                break;
        }
        
        const ctx = document.getElementById('activation-chart').getContext('2d');
        new Chart(ctx, {
            type: 'line',
            data: {
                labels: x,
                datasets: [{
                    label: type.replace('_', ' ').toUpperCase(),
                    data: y,
                    borderColor: 'var(--primary-color)',
                    pointRadius: 0
                }]
            },
            options: {
                scales: {
                    x: { title: { display: true, text: 'Input' } },
                    y: { title: { display: true, text: 'Output' } }
                }
            }
        });
    }

    // Slide 13: Enhanced FFT with proper chart management
    let timeChart = null;
    let freqChart = null;
    
    function updateFFT() {
        const freq1 = parseInt(document.getElementById('freq1').value);
        const freq2 = parseInt(document.getElementById('freq2').value);
        const noiseLevel = parseFloat(document.getElementById('noise-level').value);
        
        document.getElementById('freq1-val').innerText = freq1;
        document.getElementById('freq2-val').innerText = freq2;
        document.getElementById('noise-val').innerText = noiseLevel;
        
        const samplingRate = 100;
        const duration = 2;
        const numPoints = samplingRate * duration;
        const time = Array.from({length: numPoints}, (_, i) => i / samplingRate);
        
        // Generate composite signal with noise
        const signal = time.map(t => 
            Math.sin(2 * Math.PI * freq1 * t) + 
            0.7 * Math.sin(2 * Math.PI * freq2 * t) + 
            noiseLevel * (Math.random() - 0.5) * 2
        );
        
        // Clear previous charts
        if (timeChart) timeChart.destroy();
        if (freqChart) freqChart.destroy();
        
        // Time domain plot (show first 1 second)
        const timeCtx = document.getElementById('signal-time-chart').getContext('2d');
        const displayPoints = Math.min(100, numPoints); // Show first 1 second
        timeChart = new Chart(timeCtx, {
            type: 'line',
            data: {
                labels: time.slice(0, displayPoints),
                datasets: [{
                    label: `Combined Signal (${freq1}Hz + ${freq2}Hz) + Noise`,
                    data: signal.slice(0, displayPoints),
                    borderColor: '#00d9ff',
                    backgroundColor: 'rgba(0, 217, 255, 0.1)',
                    pointRadius: 0,
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: 'Time Domain Signal', color: 'white' },
                    legend: { labels: { color: 'white' } }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Time (s)', color: 'white' },
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    },
                    y: { 
                        title: { display: true, text: 'Amplitude', color: 'white' },
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    }
                }
            }
        });
        
        // Compute FFT
        const { freqs, magnitudes } = fft(signal, samplingRate);
        
        // Frequency domain plot (show up to 25 Hz)
        const maxFreqIdx = freqs.findIndex(f => f > 25) || freqs.length;
        const freqCtx = document.getElementById('signal-freq-chart').getContext('2d');
        freqChart = new Chart(freqCtx, {
            type: 'line',
            data: {
                labels: freqs.slice(0, maxFreqIdx),
                datasets: [{
                    label: 'FFT Magnitude Spectrum',
                    data: magnitudes.slice(0, maxFreqIdx),
                    borderColor: '#8a2be2',
                    backgroundColor: 'rgba(138, 43, 226, 0.2)',
                    pointRadius: 0,
                    borderWidth: 2,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: 'Frequency Domain (FFT)', color: 'white' },
                    legend: { labels: { color: 'white' } }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Frequency (Hz)', color: 'white' },
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    },
                    y: { 
                        title: { display: true, text: 'Magnitude', color: 'white' },
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    }
                }
            }
        });
    }
    
    document.getElementById('freq1').addEventListener('input', updateFFT);
    document.getElementById('freq2').addEventListener('input', updateFFT);
    document.getElementById('noise-level').addEventListener('input', updateFFT);

    // Slide 13: Enhanced STFT with proper spectrogram
    let stftChart = null;
    
    function updateSTFT() {
        const windowSize = parseInt(document.getElementById('stft-window').value);
        document.getElementById('window-val').innerText = windowSize;
        
        // Generate a realistic EEG-like signal with multiple frequency components
        const samplingRate = 100;
        const duration = 4; // 4 seconds
        const numPoints = samplingRate * duration;
        const time = Array.from({length: numPoints}, (_, i) => i / samplingRate);
        
        // Create signal with time-varying frequencies (simulating EEG state changes)
        const signal = time.map(t => {
            let value = 0;
            
            // Alpha waves (8-12 Hz) - stronger in first half
            if (t < 2) {
                value += 1.5 * Math.sin(2 * Math.PI * 10 * t) * Math.exp(-(t-1)*(t-1)/0.5);
            }
            
            // Beta waves (15-25 Hz) - stronger in second half
            if (t > 1.5) {
                value += 1.2 * Math.sin(2 * Math.PI * 20 * t) * (1 - Math.exp(-(t-2)*(t-2)/0.5));
            }
            
            // Theta waves (4-8 Hz) - present throughout
            value += 0.8 * Math.sin(2 * Math.PI * 6 * t);
            
            // Add some noise
            value += 0.3 * (Math.random() - 0.5);
            
            return value;
        });
        
        // Compute STFT
        const overlap = 0.75; // 75% overlap
        const hopSize = Math.floor(windowSize * (1 - overlap));
        const numWindows = Math.floor((numPoints - windowSize) / hopSize) + 1;
        const freqBins = windowSize / 2;
        
        // STFT matrix
        const stft = [];
        const freqs = Array.from({length: freqBins}, (_, i) => i * samplingRate / windowSize);
        const times = Array.from({length: numWindows}, (_, i) => i * hopSize / samplingRate);
        
        // Hamming window
        const window = Array.from({length: windowSize}, (_, i) => 
            0.54 - 0.46 * Math.cos(2 * Math.PI * i / (windowSize - 1))
        );
        
        for (let winIdx = 0; winIdx < numWindows; winIdx++) {
            const startIdx = winIdx * hopSize;
            const windowed = [];
            
            // Apply window and extract segment
            for (let i = 0; i < windowSize; i++) {
                if (startIdx + i < signal.length) {
                    windowed.push(signal[startIdx + i] * window[i]);
                } else {
                    windowed.push(0); // Zero padding
                }
            }
            
            // Compute FFT for this window
            const {magnitudes} = fft(windowed, samplingRate);
            stft.push(magnitudes);
        }
        
        // Draw spectrogram
        const canvas = document.getElementById('stft-chart');
        const ctx = canvas.getContext('2d');
        
        // Clear canvas
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Find max magnitude for normalization
        const maxMag = Math.max(...stft.flat());
        
        // Draw STFT as heatmap
        const timeStep = canvas.width / numWindows;
        const freqStep = canvas.height / freqBins;
        
        for (let t = 0; t < numWindows; t++) {
            for (let f = 0; f < freqBins; f++) {
                if (freqs[f] <= 30) { // Only show up to 30 Hz
                    const magnitude = stft[t][f] / maxMag;
                    const intensity = Math.pow(magnitude, 0.3); // Gamma correction
                    
                    // Jet colormap for spectrogram
                    let r, g, b;
                    if (intensity < 0.25) {
                        r = 0;
                        g = Math.floor(intensity * 4 * 255);
                        b = 255;
                    } else if (intensity < 0.5) {
                        r = 0;
                        g = 255;
                        b = Math.floor((1 - (intensity - 0.25) * 4) * 255);
                    } else if (intensity < 0.75) {
                        r = Math.floor((intensity - 0.5) * 4 * 255);
                        g = 255;
                        b = 0;
                    } else {
                        r = 255;
                        g = Math.floor((1 - (intensity - 0.75) * 4) * 255);
                        b = 0;
                    }
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(
                        t * timeStep,
                        canvas.height - (f + 1) * freqStep,
                        timeStep,
                        freqStep
                    );
                }
            }
        }
        
        // Add labels and grid
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        
        // Title
        ctx.fillText(`STFT Spectrogram (Window: ${windowSize} samples)`, 10, 20);
        
        // Axes labels
        ctx.fillText('Time (s) ‚Üí', 10, canvas.height - 5);
        ctx.save();
        ctx.translate(15, canvas.height - 50);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Frequency (Hz) ‚Üë', 0, 0);
        ctx.restore();
        
        // Frequency scale
        ctx.font = '10px Arial';
        const freqMarks = [5, 10, 15, 20, 25, 30];
        freqMarks.forEach(freq => {
            const yPos = canvas.height - (freq / 30) * canvas.height;
            if (yPos > 20) {
                ctx.fillText(`${freq}`, canvas.width - 25, yPos);
            }
        });
        
        // Time scale
        const timeMarks = [1, 2, 3, 4];
        timeMarks.forEach(t => {
            const xPos = (t / 4) * canvas.width;
            if (xPos < canvas.width - 30) {
                ctx.fillText(`${t}s`, xPos, canvas.height - 10);
            }
        });
    }
    
    // Event listeners for interactive elements
    document.getElementById('freq1').addEventListener('input', updateFFT);
    document.getElementById('freq2').addEventListener('input', updateFFT);
    document.getElementById('noise-level').addEventListener('input', updateFFT);
    document.getElementById('stft-window').addEventListener('input', updateSTFT);
    document.getElementById('wavelet-type').addEventListener('change', updateWavelet);
    document.getElementById('wavelet-freq').addEventListener('input', updateWavelet);
    
    // Slide 14: Enhanced Wavelet Analysis
    let waveletChart = null;
    
    function updateWavelet() {
        const waveletType = document.getElementById('wavelet-type').value;
        const centerFreq = parseInt(document.getElementById('wavelet-freq').value);
        
        document.getElementById('wav-freq-val').innerText = centerFreq;
        
        // Generate mother wavelet with proper scaling
        const duration = 2; // 2 seconds around center
        const fs = 100; // sampling frequency
        const numPoints = duration * fs;
        const time = Array.from({length: numPoints}, (_, i) => (i - numPoints/2) / fs);
        let wavelet;
        
        if (waveletType === 'morlet') {
            // Morlet wavelet: Gaussian-modulated complex exponential
            const sigma = 1.0 / centerFreq; // Scale with frequency
            wavelet = time.map(t => {
                const envelope = Math.exp(-t*t / (2 * sigma * sigma));
                const oscillation = Math.cos(2 * Math.PI * centerFreq * t);
                return envelope * oscillation;
            });
        } else { // mexican_hat
            // Mexican Hat wavelet (Ricker wavelet)
            const sigma = 1.0 / centerFreq;
            wavelet = time.map(t => {
                const normT = t / sigma;
                return (1 - normT * normT) * Math.exp(-normT * normT / 2);
            });
        }
        
        // Clear previous chart
        if (waveletChart) waveletChart.destroy();
        
        // Plot mother wavelet
        const ctx = document.getElementById('wavelet-chart').getContext('2d');
        waveletChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: time.map(t => t.toFixed(2)),
                datasets: [{
                    label: `${waveletType.charAt(0).toUpperCase() + waveletType.slice(1)} Wavelet (${centerFreq} Hz)`,
                    data: wavelet,
                    borderColor: '#00d9ff',
                    backgroundColor: 'rgba(0, 217, 255, 0.1)',
                    pointRadius: 0,
                    borderWidth: 2,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: 'Mother Wavelet', color: 'white' },
                    legend: { labels: { color: 'white' } }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Time (s)', color: 'white' },
                        ticks: { color: 'white', maxTicksLimit: 10 },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    },
                    y: { 
                        title: { display: true, text: 'Amplitude', color: 'white' },
                        ticks: { color: 'white' },
                        grid: { color: 'rgba(255,255,255,0.1)' }
                    }
                }
            }
        });
        
        // Generate realistic EEG-like signal for scalogram
        const signalDuration = 3; // 3 seconds
        const signalPoints = signalDuration * fs;
        const signalTime = Array.from({length: signalPoints}, (_, i) => i / fs);
        
        // Create EEG-like signal with multiple frequency bands
        const signal = signalTime.map(t => {
            let value = 0;
            
            // Alpha burst at t=1s
            if (t > 0.8 && t < 1.5) {
                value += 2 * Math.sin(2 * Math.PI * 10 * t) * Math.exp(-Math.pow(t-1.15, 2) / 0.05);
            }
            
            // Beta activity increasing over time
            value += 0.5 * (1 + t/3) * Math.sin(2 * Math.PI * 20 * t);
            
            // Theta background
            value += 0.3 * Math.sin(2 * Math.PI * 5 * t);
            
            // Add realistic noise
            value += 0.2 * (Math.random() - 0.5);
            
            return value;
        });
        
        // Compute and display scalogram
        generateScalogram(signal, fs);
    }
    
    function generateScalogram(signal, fs) {
        const canvas = document.getElementById('scalogram-chart');
        const ctx = canvas.getContext('2d');
        
        // Clear canvas
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const N = signal.length;
        const scales = 64; // Number of scales
        const minFreq = 1;
        const maxFreq = 30; // Focus on EEG-relevant frequencies
        const timeSteps = 80; // Subsample for visualization
        
        // Create scalogram matrix
        const scalogram = [];
        
        for (let scaleIdx = 0; scaleIdx < scales; scaleIdx++) {
            const freq = minFreq + (maxFreq - minFreq) * scaleIdx / scales;
            const sigma = 1.0 / freq; // Morlet wavelet parameter
            const timeRow = [];
            
            for (let timeIdx = 0; timeIdx < timeSteps; timeIdx++) {
                const timePoint = Math.floor(timeIdx * N / timeSteps);
                
                // Morlet wavelet convolution at this time point
                let real = 0, imag = 0;
                const windowSize = Math.min(N, Math.ceil(6 * sigma * fs)); // 6 sigma window
                
                for (let i = Math.max(0, timePoint - windowSize/2); 
                     i < Math.min(N, timePoint + windowSize/2); i++) {
                    const tau = (i - timePoint) / fs;
                    const envelope = Math.exp(-tau * tau / (2 * sigma * sigma));
                    const oscillationReal = Math.cos(2 * Math.PI * freq * tau);
                    const oscillationImag = Math.sin(2 * Math.PI * freq * tau);
                    
                    real += signal[i] * envelope * oscillationReal;
                    imag += signal[i] * envelope * oscillationImag;
                }
                
                const magnitude = Math.sqrt(real * real + imag * imag);
                timeRow.push(magnitude);
            }
            scalogram.push(timeRow);
        }
        
        // Find max value for normalization
        const maxVal = Math.max(...scalogram.flat());
        
        // Draw scalogram with enhanced visualization
        const pixelWidth = canvas.width / timeSteps;
        const pixelHeight = canvas.height / scales;
        
        for (let t = 0; t < timeSteps; t++) {
            for (let s = 0; s < scales; s++) {
                const value = scalogram[s][t] / maxVal;
                const intensity = Math.pow(value, 0.4); // Gamma correction for better visibility
                
                // Enhanced jet colormap
                let r, g, b;
                if (intensity < 0.2) {
                    r = 0;
                    g = Math.floor(intensity * 5 * 255);
                    b = 255;
                } else if (intensity < 0.4) {
                    r = 0;
                    g = 255;
                    b = Math.floor((1 - (intensity - 0.2) * 5) * 255);
                } else if (intensity < 0.6) {
                    r = Math.floor((intensity - 0.4) * 5 * 255);
                    g = 255;
                    b = 0;
                } else if (intensity < 0.8) {
                    r = 255;
                    g = Math.floor((1 - (intensity - 0.6) * 5) * 255);
                    b = 0;
                } else {
                    r = 255;
                    g = 0;
                    b = Math.floor((intensity - 0.8) * 5 * 255);
                }
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(
                    t * pixelWidth,
                    canvas.height - (s + 1) * pixelHeight,
                    pixelWidth,
                    pixelHeight
                );
            }
        }
        
        // Add professional labels and annotations
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px Arial';
        ctx.fillText('Morlet Wavelet Scalogram - EEG Analysis', 10, 20);
        
        ctx.font = '12px Arial';
        ctx.fillText('Time (s) ‚Üí', 10, canvas.height - 5);
        ctx.save();
        ctx.translate(15, canvas.height - 50);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Frequency (Hz) ‚Üë', 0, 0);
        ctx.restore();
        
        // Add EEG band annotations
        ctx.font = '10px Arial';
        const eegBands = [
            {name: 'Œ¥', freq: 2, color: 'lightblue'},
            {name: 'Œ∏', freq: 6, color: 'lightgreen'},
            {name: 'Œ±', freq: 10, color: 'yellow'},
            {name: 'Œ≤', freq: 20, color: 'orange'}
        ];
        
        eegBands.forEach(band => {
            const yPos = canvas.height - (band.freq - minFreq) / (maxFreq - minFreq) * canvas.height;
            if (yPos > 20 && yPos < canvas.height - 20) {
                ctx.fillStyle = band.color;
                ctx.fillText(`${band.name} (${band.freq}Hz)`, canvas.width - 60, yPos);
                
                // Draw frequency line
                ctx.strokeStyle = band.color;
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, yPos);
                ctx.lineTo(canvas.width - 65, yPos);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
        
        // Time markers
        ctx.fillStyle = 'white';
        const timeMarkers = [0.5, 1.0, 1.5, 2.0, 2.5];
        timeMarkers.forEach(t => {
            const xPos = (t / 3) * canvas.width;
            if (xPos < canvas.width - 50) {
                ctx.fillText(`${t}s`, xPos, canvas.height - 10);
            }
        });
    }

    // --- POWER ANALYSIS FUNCTION ---
    function runPowerAnalysis() {
        const alpha = parseFloat(document.getElementById('power-alpha').value);
        const effectSize = parseFloat(document.getElementById('power-effect-size').value);
        const power = parseFloat(document.getElementById('power-target').value);
        
        // Calculate required sample size using Cohen's formula
        // For two-sample t-test: n = 2 * (z_Œ±/2 + z_Œ≤)¬≤ / d¬≤
        const zAlpha = getZScore(1 - alpha/2);
        const zBeta = getZScore(power);
        const sampleSize = Math.ceil(2 * Math.pow(zAlpha + zBeta, 2) / Math.pow(effectSize, 2));
        
        document.getElementById('power-results').innerHTML = `
            <h4>Power Analysis Results</h4>
            <p><strong>Required Sample Size:</strong> ${sampleSize} per group (${sampleSize * 2} total)</p>
            <p><strong>Effect Size (Cohen's d):</strong> ${effectSize} (${getEffectSizeInterpretation(effectSize)})</p>
            <p><strong>Significance Level (Œ±):</strong> ${alpha}</p>
            <p><strong>Power (1-Œ≤):</strong> ${power}</p>
        `;
        
        // Create power curve visualization
        const powerCanvas = document.getElementById('power-curve');
        const powerCtx = powerCanvas.getContext('2d');
        
        if (window.powerChart) {
            window.powerChart.destroy();
        }
        
        // Generate power curve data
        const sampleSizes = [];
        const powerValues = [];
        
        for (let n = 5; n <= 200; n += 5) {
            sampleSizes.push(n);
            const powerForN = calculatePowerForSampleSize(n, effectSize, alpha);
            powerValues.push(powerForN);
        }
        
        window.powerChart = new Chart(powerCtx, {
            type: 'line',
            data: {
                labels: sampleSizes,
                datasets: [{
                    label: 'Statistical Power',
                    data: powerValues,
                    borderColor: 'rgba(0, 217, 255, 1)',
                    backgroundColor: 'rgba(0, 217, 255, 0.1)',
                    borderWidth: 2,
                    fill: true
                }, {
                    label: 'Target Power',
                    data: Array(sampleSizes.length).fill(power),
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Power Analysis Curve',
                        color: '#00d9ff'
                    },
                    legend: {
                        labels: {
                            color: '#00d9ff'
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Sample Size (per group)',
                            color: '#00d9ff'
                        },
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Statistical Power',
                            color: '#00d9ff'
                        },
                        min: 0,
                        max: 1,
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    }
                }
            }
        });
    }

    function getZScore(probability) {
        // Approximate inverse normal function for common values
        if (probability >= 0.5) {
            if (probability === 0.8) return 0.84;
            if (probability === 0.9) return 1.28;
            if (probability === 0.95) return 1.645;
            if (probability === 0.975) return 1.96;
            if (probability === 0.99) return 2.33;
            if (probability === 0.995) return 2.58;
        }
        // Rough approximation for other values
        return Math.sqrt(-2 * Math.log(1 - probability));
    }

    function getEffectSizeInterpretation(d) {
        if (d < 0.2) return 'Very Small';
        if (d < 0.5) return 'Small';
        if (d < 0.8) return 'Medium';
        return 'Large';
    }

    function calculatePowerForSampleSize(n, effectSize, alpha) {
        const zAlpha = getZScore(1 - alpha/2);
        const delta = effectSize * Math.sqrt(n/2);
        // Approximate power calculation
        const zBeta = delta - zAlpha;
        return Math.min(0.99, Math.max(0.05, 1 - (1 - normalCDF(zBeta))));
    }

    function normalCDF(z) {
        // Approximation of normal CDF
        return 0.5 * (1 + erf(z / Math.sqrt(2)));
    }

    function erf(x) {
        // Approximation of error function
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;
        
        const sign = x >= 0 ? 1 : -1;
        x = Math.abs(x);
        
        const t = 1.0 / (1.0 + p * x);
        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        
        return sign * y;
    }

    // --- LOGISTIC REGRESSION FUNCTIONS ---
    let logisticData = [];
    let logisticModel = null;

    function testLogisticFunction() {
        console.log('Testing logistic function...');
        console.log('Chart.js available:', typeof Chart !== 'undefined');
        console.log('Canvas element exists:', !!document.getElementById('logistic-plot'));
        console.log('Input elements exist:', 
                   !!document.getElementById('logistic-n'), 
                   !!document.getElementById('logistic-coef'));
        
        // Test basic Chart.js functionality
        const canvas = document.getElementById('logistic-plot');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            if (window.testChart) window.testChart.destroy();
            
            window.testChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Test Data',
                        data: [{x: 1, y: 1}, {x: 2, y: 2}, {x: 3, y: 1}],
                        backgroundColor: 'rgba(0, 217, 255, 0.6)',
                        pointRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: 'Test Chart', color: '#00d9ff' }
                    }
                }
            });
            console.log('Test chart created successfully');
        }
    }

    function generateLogisticData() {
        const nElement = document.getElementById('logistic-n');
        const coefElement = document.getElementById('logistic-coef');
        
        if (!nElement || !coefElement) {
            console.error('Required input elements not found');
            return;
        }
        
        const n = parseInt(nElement.value);
        const trueCoef = parseFloat(coefElement.value);
        
        console.log('Generating logistic data with n=', n, 'coef=', trueCoef);
        
        logisticData = [];
        
        for (let i = 0; i < n; i++) {
            const x = (Math.random() - 0.5) * 6; // Random x between -3 and 3
            const z = -1 + trueCoef * x; // Linear combination
            const prob = 1 / (1 + Math.exp(-z)); // Logistic function
            const y = Math.random() < prob ? 1 : 0; // Bernoulli outcome
            
            logisticData.push({ x: x, y: y, prob: prob });
        }
        
        // Update display values
        document.getElementById('logistic-n-val').textContent = n;
        document.getElementById('logistic-coef-val').textContent = trueCoef;
        
        plotLogisticData();
    }

    // Simplified single-click logistic regression
    function generateLogisticPlot() {
        const n = parseInt(document.getElementById('logistic-n').value);
        const coef = parseFloat(document.getElementById('logistic-coef').value);
        
        // Update display values
        document.getElementById('logistic-n-val').textContent = n;
        document.getElementById('logistic-coef-val').textContent = coef;
        
        // Generate sample data
        const sampleData = [];
        for (let i = 0; i < n; i++) {
            const x = (Math.random() - 0.5) * 6;
            const z = -1 + coef * x;
            const prob = 1 / (1 + Math.exp(-z));
            const y = Math.random() < prob ? 1 : 0;
            sampleData.push({ x: x, y: y, prob: prob });
        }
        
        // Separate data by outcome
        const class0 = sampleData.filter(d => d.y === 0);
        const class1 = sampleData.filter(d => d.y === 1);
        
        // Generate logistic curve
        const xRange = [];
        const yRange = [];
        for (let x = -3; x <= 3; x += 0.1) {
            const z = -1 + coef * x;
            const prob = 1 / (1 + Math.exp(-z));
            xRange.push(x);
            yRange.push(prob);
        }
        
        const canvas = document.getElementById('logistic-plot');
        const ctx = canvas.getContext('2d');
        
        if (window.logisticChart) window.logisticChart.destroy();
        
        window.logisticChart = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Outcome = 0',
                    data: class0.map(d => ({ 
                        x: d.x, 
                        y: d.y + (Math.random() - 0.5) * 0.1
                    })),
                    backgroundColor: 'rgba(255, 99, 132, 0.6)',
                    pointRadius: 3,
                    type: 'scatter'
                }, {
                    label: 'Outcome = 1',
                    data: class1.map(d => ({ 
                        x: d.x, 
                        y: d.y + (Math.random() - 0.5) * 0.1
                    })),
                    backgroundColor: 'rgba(0, 217, 255, 0.6)',
                    pointRadius: 3,
                    type: 'scatter'
                }, {
                    label: 'Logistic Curve',
                    data: xRange.map((x, i) => ({ x: x, y: yRange[i] })),
                    borderColor: '#00ff00',
                    backgroundColor: 'rgba(0, 255, 0, 0.1)',
                    borderWidth: 3,
                    pointRadius: 0,
                    type: 'line',
                    fill: false
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: { display: true, text: 'Logistic Regression', color: '#00d9ff' },
                    legend: { labels: { color: '#00d9ff' } }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'X Variable', color: '#00d9ff' },
                        ticks: { color: '#00d9ff' },
                        grid: { color: 'rgba(0, 217, 255, 0.3)' }
                    },
                    y: { 
                        title: { display: true, text: 'Probability / Outcome', color: '#00d9ff' },
                        min: -0.1, max: 1.1,
                        ticks: { color: '#00d9ff' },
                        grid: { color: 'rgba(0, 217, 255, 0.3)' }
                    }
                }
            }
        });
        
        // Display results
        const oddsRatio = Math.exp(coef);
        document.getElementById('logistic-results').innerHTML = `
            <h4>Logistic Regression Results</h4>
            <p><strong>Coefficient (Œ≤‚ÇÅ):</strong> ${coef.toFixed(3)}</p>
            <p><strong>Odds Ratio (e^Œ≤‚ÇÅ):</strong> ${oddsRatio.toFixed(3)}</p>
            <p><strong>Sample Size:</strong> ${n} observations</p>
        `;
    }

    function plotLogisticData() {
        const canvas = document.getElementById('logistic-plot');
        if (!canvas) {
            console.error('Canvas element logistic-plot not found');
            return;
        }
        
        const ctx = canvas.getContext('2d');
        
        if (window.logisticChart) {
            window.logisticChart.destroy();
        }
        
        // Separate data by outcome and add jitter for visualization
        const class0 = logisticData.filter(d => d.y === 0);
        const class1 = logisticData.filter(d => d.y === 1);
        
        console.log('Plotting logistic data:', { class0: class0.length, class1: class1.length });
        
        window.logisticChart = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Outcome = 0',
                    data: class0.map(d => ({ 
                        x: d.x, 
                        y: d.y + (Math.random() - 0.5) * 0.1 // Add small jitter for visibility
                    })),
                    backgroundColor: 'rgba(255, 99, 132, 0.6)',
                    pointRadius: 4
                }, {
                    label: 'Outcome = 1',
                    data: class1.map(d => ({ 
                        x: d.x, 
                        y: d.y + (Math.random() - 0.5) * 0.1 // Add small jitter for visibility
                    })),
                    backgroundColor: 'rgba(0, 217, 255, 0.6)',
                    pointRadius: 4
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Logistic Regression Data',
                        color: '#00d9ff'
                    },
                    legend: {
                        labels: {
                            color: '#00d9ff'
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Predictor (X)',
                            color: '#00d9ff'
                        },
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Outcome (Y)',
                            color: '#00d9ff'
                        },
                        min: -0.1,
                        max: 1.1,
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    }
                }
            }
        });
    }

    function fitLogisticModel() {
        if (logisticData.length === 0) {
            generateLogisticData();
        }
        
        // Simple logistic regression using iterative method
        let beta0 = 0;
        let beta1 = 0;
        const learningRate = 0.01;
        const iterations = 1000;
        
        for (let iter = 0; iter < iterations; iter++) {
            let grad0 = 0;
            let grad1 = 0;
            
            for (const point of logisticData) {
                const z = beta0 + beta1 * point.x;
                const pred = 1 / (1 + Math.exp(-z));
                const error = point.y - pred;
                
                grad0 += error;
                grad1 += error * point.x;
            }
            
            beta0 += learningRate * grad0 / logisticData.length;
            beta1 += learningRate * grad1 / logisticData.length;
        }
        
        logisticModel = { beta0: beta0, beta1: beta1 };
        
        // Add fitted curve to plot
        const xRange = [];
        const yRange = [];
        
        for (let x = -3; x <= 3; x += 0.1) {
            const z = beta0 + beta1 * x;
            const prob = 1 / (1 + Math.exp(-z));
            xRange.push(x);
            yRange.push(prob);
        }
        
        // Update chart with fitted line
        window.logisticChart.data.datasets.push({
            label: 'Fitted Curve',
            data: xRange.map((x, i) => ({ x: x, y: yRange[i] })),
            type: 'line',
            borderColor: 'rgba(255, 206, 84, 1)',
            backgroundColor: 'transparent',
            borderWidth: 3,
            pointRadius: 0,
            tension: 0.4
        });
        
        window.logisticChart.update();
        
        // Calculate and display results
        const oddsRatio = Math.exp(beta1);
        
        document.getElementById('logistic-results').innerHTML = `
            <h4>Logistic Regression Results</h4>
            <p><strong>Intercept (Œ≤‚ÇÄ):</strong> ${beta0.toFixed(3)}</p>
            <p><strong>Slope (Œ≤‚ÇÅ):</strong> ${beta1.toFixed(3)}</p>
            <p><strong>Odds Ratio (e^Œ≤‚ÇÅ):</strong> ${oddsRatio.toFixed(3)}</p>
            <p><strong>Interpretation:</strong> For each unit increase in X, the odds of Y=1 ${oddsRatio > 1 ? 'increase' : 'decrease'} by a factor of ${Math.abs(oddsRatio).toFixed(2)}</p>
        `;
        
        // Generate ROC curve
        generateROCCurve();
    }

    function generateROCCurve() {
        if (!logisticModel || logisticData.length === 0) {
            console.error('No logistic model or data available. Please generate data and fit model first.');
            document.getElementById('roc-results').innerHTML = '<p style="color: red;">Please generate data and fit model first!</p>';
            return;
        }
        
        console.log('Generating ROC curve with', logisticData.length, 'data points');
        
        // Calculate predicted probabilities
        const predictions = logisticData.map(point => {
            const z = logisticModel.beta0 + logisticModel.beta1 * point.x;
            return {
                prob: 1 / (1 + Math.exp(-z)),
                actual: point.y
            };
        });
        
        // Calculate ROC points
        const thresholds = [];
        for (let t = 0; t <= 1; t += 0.01) {
            thresholds.push(t);
        }
        
        const rocPoints = thresholds.map(threshold => {
            let tp = 0, fp = 0, tn = 0, fn = 0;
            
            predictions.forEach(pred => {
                const predicted = pred.prob >= threshold ? 1 : 0;
                if (pred.actual === 1 && predicted === 1) tp++;
                else if (pred.actual === 0 && predicted === 1) fp++;
                else if (pred.actual === 0 && predicted === 0) tn++;
                else if (pred.actual === 1 && predicted === 0) fn++;
            });
            
            const tpr = tp / (tp + fn) || 0; // Sensitivity
            const fpr = fp / (fp + tn) || 0; // 1 - Specificity
            
            return { x: fpr, y: tpr };
        });
        
        // Calculate AUC using trapezoidal rule
        let auc = 0;
        for (let i = 1; i < rocPoints.length; i++) {
            const dx = rocPoints[i].x - rocPoints[i-1].x;
            const avgY = (rocPoints[i].y + rocPoints[i-1].y) / 2;
            auc += dx * avgY;
        }
        
        // Plot ROC curve
        const rocCanvas = document.getElementById('roc-curve');
        if (!rocCanvas) {
            console.error('ROC canvas element not found');
            return;
        }
        
        const rocCtx = rocCanvas.getContext('2d');
        
        if (window.rocChart) {
            window.rocChart.destroy();
        }
        
        window.rocChart = new Chart(rocCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'ROC Curve',
                    data: rocPoints,
                    borderColor: 'rgba(0, 217, 255, 1)',
                    backgroundColor: 'rgba(0, 217, 255, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: true
                }, {
                    label: 'Random Classifier',
                    data: [{ x: 0, y: 0 }, { x: 1, y: 1 }],
                    borderColor: 'rgba(255, 99, 132, 0.8)',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: `ROC Curve (AUC = ${auc.toFixed(3)})`,
                        color: '#00d9ff'
                    },
                    legend: {
                        labels: {
                            color: '#00d9ff'
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'False Positive Rate (1 - Specificity)',
                            color: '#00d9ff'
                        },
                        min: 0,
                        max: 1,
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'True Positive Rate (Sensitivity)',
                            color: '#00d9ff'
                        },
                        min: 0,
                        max: 1,
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    }
                }
            }
        });
        
        document.getElementById('roc-results').innerHTML = `
            <h4>ROC Analysis</h4>
            <p><strong>AUC:</strong> ${auc.toFixed(3)}</p>
            <p><strong>Interpretation:</strong> ${auc > 0.8 ? 'Excellent' : auc > 0.7 ? 'Good' : auc > 0.6 ? 'Fair' : 'Poor'} discrimination</p>
        `;
    }

    // Simplified single-click ROC curve
    function generateROCPlot() {
        // Generate more realistic sample data for ROC demonstration
        const n = 300;
        const predictions = [];
        
        // Create two populations with different characteristics for better ROC curve
        for (let i = 0; i < n; i++) {
            let actual, predicted;
            
            if (i < n/2) {
                // Negative class (actual = 0): lower predicted probabilities
                actual = 0;
                predicted = Math.random() * 0.6 + (Math.random() - 0.5) * 0.2; // Centered around 0.3
            } else {
                // Positive class (actual = 1): higher predicted probabilities  
                actual = 1;
                predicted = Math.random() * 0.6 + 0.4 + (Math.random() - 0.5) * 0.2; // Centered around 0.7
            }
            
            predictions.push({ 
                prob: Math.max(0.01, Math.min(0.99, predicted)), // Clamp between 0.01 and 0.99
                actual: actual 
            });
        }
        
        // Calculate ROC points with more thresholds for smoother curve
        const thresholds = [];
        for (let t = 0; t <= 1; t += 0.01) {
            thresholds.push(t);
        }
        
        const rocPoints = [];
        
        // Add starting point (1, 1) - threshold = 0, all predicted positive
        rocPoints.push({ x: 1, y: 1 });
        
        thresholds.forEach(threshold => {
            let tp = 0, fp = 0, tn = 0, fn = 0;
            
            predictions.forEach(pred => {
                const predicted = pred.prob >= threshold ? 1 : 0;
                if (pred.actual === 1 && predicted === 1) tp++;
                else if (pred.actual === 0 && predicted === 1) fp++;
                else if (pred.actual === 0 && predicted === 0) tn++;
                else if (pred.actual === 1 && predicted === 0) fn++;
            });
            
            const tpr = (tp + fn) > 0 ? tp / (tp + fn) : 0; // Sensitivity
            const fpr = (fp + tn) > 0 ? fp / (fp + tn) : 0; // 1 - Specificity
            
            rocPoints.push({ x: fpr, y: tpr });
        });
        
        // Add ending point (0, 0) - threshold = 1, all predicted negative
        rocPoints.push({ x: 0, y: 0 });
        
        // Sort ROC points by FPR for proper curve drawing
        rocPoints.sort((a, b) => a.x - b.x);
        
        // Calculate AUC using trapezoidal rule
        let auc = 0;
        for (let i = 1; i < rocPoints.length; i++) {
            const dx = rocPoints[i].x - rocPoints[i-1].x;
            const avgY = (rocPoints[i].y + rocPoints[i-1].y) / 2;
            auc += dx * avgY;
        }
        
        const canvas = document.getElementById('roc-curve');
        const ctx = canvas.getContext('2d');
        
        if (window.rocChart) window.rocChart.destroy();
        
        window.rocChart = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'ROC Curve',
                    data: rocPoints,
                    borderColor: 'rgba(0, 217, 255, 1)',
                    backgroundColor: 'rgba(0, 217, 255, 0.1)',
                    borderWidth: 3,
                    pointRadius: 2,
                    showLine: true,
                    fill: true
                }, {
                    label: 'Random Classifier',
                    data: [{ x: 0, y: 0 }, { x: 1, y: 1 }],
                    borderColor: 'rgba(255, 99, 132, 0.8)',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    pointRadius: 0,
                    showLine: true,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: `ROC Curve (AUC = ${auc.toFixed(3)})`,
                        color: '#00d9ff'
                    },
                    legend: { labels: { color: '#00d9ff' } }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'False Positive Rate', color: '#00d9ff' },
                        min: 0, max: 1,
                        ticks: { color: '#00d9ff' },
                        grid: { color: 'rgba(0, 217, 255, 0.3)' }
                    },
                    y: {
                        title: { display: true, text: 'True Positive Rate', color: '#00d9ff' },
                        min: 0, max: 1,
                        ticks: { color: '#00d9ff' },
                        grid: { color: 'rgba(0, 217, 255, 0.3)' }
                    }
                }
            }
        });
        
        document.getElementById('roc-results').innerHTML = `
            <h4>ROC Analysis Results</h4>
            <p><strong>AUC:</strong> ${auc.toFixed(3)}</p>
            <p><strong>Interpretation:</strong> ${auc > 0.8 ? 'Excellent' : auc > 0.7 ? 'Good' : auc > 0.6 ? 'Fair' : 'Poor'} discrimination</p>
            <p><strong>Sample Size:</strong> ${n} predictions</p>
        `;
    }

    // --- NEURAL NETWORK DEMO FUNCTIONS ---
    function runNeuralNetworkDemo() {
        try {
            // Check if Chart.js is available
            if (typeof Chart === 'undefined') {
                throw new Error('Chart.js library is not loaded');
            }
            
            const learningType = document.getElementById('learning-type').value;
            const complexity = parseInt(document.getElementById('nn-complexity').value);
            
            // Update display value
            document.getElementById('nn-complexity-val').textContent = complexity;
            
            console.log(`Running neural network demo: ${learningType}, complexity: ${complexity}`);
            
            if (learningType === 'supervised') {
                runSupervisedDemo(complexity);
            } else {
                runUnsupervisedDemo(complexity);
            }
        } catch (error) {
            console.error('Neural network demo error:', error);
            document.getElementById('neural-network-results').innerHTML = `
                <p style="color: #ff6b6b;">Error running neural network demo: ${error.message}</p>
                <p>Please try refreshing the page or check browser console for details.</p>
            `;
        }
    }
    
    function runSupervisedDemo(complexity) {
        // Create neural network architecture
        const network = createNeuralNetwork(2, complexity, false); // 2 inputs (stress, sleep)
        
        // Generate and train on data
        const data = generateClassificationData(100);
        const trainingResults = trainNetwork(network, data, 50);
        
        // Show network architecture and results
        plotNeuralNetworkArchitecture(network, data, trainingResults, 'supervised', complexity);
    }
    
    function runUnsupervisedDemo(complexity) {
        // Create autoencoder-style network for clustering
        const network = createNeuralNetwork(2, complexity, true); // 2 inputs (anxiety, depression)
        
        // Generate clustering data
        const data = generateClusteringData(100);
        const trainingResults = trainNetworkUnsupervised(network, data, 30);
        
        // Show network architecture and results
        plotNeuralNetworkArchitecture(network, data, trainingResults, 'unsupervised', complexity);
    }
    
    function createNeuralNetwork(inputSize, complexity, isUnsupervised) {
        const hiddenSize = complexity * 4; // 4, 8, 12, 16, 20 neurons
        const outputSize = isUnsupervised ? 3 : 1; // 3 clusters or 1 classification
        
        const network = {
            layers: [
                { 
                    name: 'Input', 
                    size: inputSize, 
                    neurons: Array(inputSize).fill(0),
                    weights: null,
                    biases: null
                },
                { 
                    name: 'Hidden', 
                    size: hiddenSize, 
                    neurons: Array(hiddenSize).fill(0),
                    weights: [],
                    biases: []
                },
                { 
                    name: 'Output', 
                    size: outputSize, 
                    neurons: Array(outputSize).fill(0),
                    weights: [],
                    biases: []
                }
            ]
        };
        
        // Initialize weights for hidden layer (input -> hidden)
        for (let i = 0; i < hiddenSize; i++) {
            const weights = [];
            for (let j = 0; j < inputSize; j++) {
                weights.push((Math.random() - 0.5) * 2); // Random weights [-1, 1]
            }
            network.layers[1].weights.push(weights);
            network.layers[1].biases.push((Math.random() - 0.5) * 2);
        }
        
        // Initialize weights for output layer (hidden -> output)
        for (let i = 0; i < outputSize; i++) {
            const weights = [];
            for (let j = 0; j < hiddenSize; j++) {
                weights.push((Math.random() - 0.5) * 2);
            }
            network.layers[2].weights.push(weights);
            network.layers[2].biases.push((Math.random() - 0.5) * 2);
        }
        
        return network;
    }
    
    function forwardPass(network, input) {
        // Input layer
        network.layers[0].neurons = [...input];
        
        // Hidden layer
        for (let i = 0; i < network.layers[1].size; i++) {
            let sum = network.layers[1].biases[i];
            for (let j = 0; j < network.layers[0].size; j++) {
                sum += network.layers[0].neurons[j] * network.layers[1].weights[i][j];
            }
            network.layers[1].neurons[i] = sigmoid(sum);
        }
        
        // Output layer
        for (let i = 0; i < network.layers[2].size; i++) {
            let sum = network.layers[2].biases[i];
            for (let j = 0; j < network.layers[1].size; j++) {
                sum += network.layers[1].neurons[j] * network.layers[2].weights[i][j];
            }
            network.layers[2].neurons[i] = sigmoid(sum);
        }
        
        return network.layers[2].neurons;
    }
    
    function sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
    }
    
    function generateClassificationData(n) {
        const data = [];
        for (let i = 0; i < n; i++) {
            const stress = Math.random() * 10;
            const sleep = Math.random() * 10;
            const risk = (stress > 6 && sleep < 4) || (stress > 8) ? 1 : 0;
            
            data.push({
                input: [stress / 10, sleep / 10], // Normalize to [0,1]
                target: risk,
                x: stress,
                y: sleep
            });
        }
        return data;
    }
    
    function generateClusteringData(n) {
        const data = [];
        const centers = [[2, 8], [8, 2], [5, 5]]; // Three cluster centers
        
        for (let i = 0; i < n; i++) {
            const clusterIdx = Math.floor(Math.random() * 3);
            const center = centers[clusterIdx];
            const anxiety = center[0] + (Math.random() - 0.5) * 2;
            const depression = center[1] + (Math.random() - 0.5) * 2;
            
            data.push({
                input: [anxiety / 10, depression / 10], // Normalize to [0,1]
                cluster: clusterIdx,
                x: anxiety,
                y: depression
            });
        }
        return data;
    }
    
    function trainNetwork(network, data, epochs) {
        const learningCurve = [];
        
        for (let epoch = 0; epoch < epochs; epoch++) {
            let totalLoss = 0;
            let correct = 0;
            
            for (const sample of data) {
                const output = forwardPass(network, sample.input);
                const loss = Math.pow(output[0] - sample.target, 2);
                totalLoss += loss;
                
                const predicted = output[0] > 0.5 ? 1 : 0;
                if (predicted === sample.target) correct++;
                
                // Simple backpropagation simulation (just for visualization)
                const learningRate = 0.1;
                const error = output[0] - sample.target;
                
                // Update output layer weights (simplified)
                for (let i = 0; i < network.layers[2].weights[0].length; i++) {
                    network.layers[2].weights[0][i] -= learningRate * error * network.layers[1].neurons[i];
                }
            }
            
            const accuracy = correct / data.length;
            learningCurve.push({ epoch, loss: totalLoss / data.length, accuracy });
        }
        
        return learningCurve;
    }
    
    function trainNetworkUnsupervised(network, data, epochs) {
        const learningCurve = [];
        
        for (let epoch = 0; epoch < epochs; epoch++) {
            let totalLoss = 0;
            
            for (const sample of data) {
                const output = forwardPass(network, sample.input);
                // For clustering, we simulate reconstruction loss
                const loss = sample.input.reduce((sum, val, idx) => 
                    sum + Math.pow(val - (output[sample.cluster] || 0.5), 2), 0);
                totalLoss += loss;
            }
            
            learningCurve.push({ epoch, loss: totalLoss / data.length });
        }
        
        return learningCurve;
    }
    
    // --- NEW NEURAL NETWORK ARCHITECTURE FUNCTIONS ---
    function plotNeuralNetworkArchitecture(network, data, trainingResults, learningType, complexity) {
        try {
            const canvas = document.getElementById('neural-network-demo');
            if (!canvas) {
                throw new Error('Canvas element not found');
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                throw new Error('Cannot get canvas context');
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = 250;
            
            // Draw neural network architecture
            drawNeuralNetwork(ctx, network, canvas.width, canvas.height);
            
            // Show sample prediction
            const sampleData = data[0];
            const prediction = forwardPass(network, sampleData.input);
            
            // Display results
            const resultsDiv = document.getElementById('neural-network-results');
            
            if (learningType === 'supervised') {
                const finalAccuracy = trainingResults[trainingResults.length - 1].accuracy;
                const finalLoss = trainingResults[trainingResults.length - 1].loss;
                
                resultsDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                        <div>
                            <h4 style="color: #00d9ff; margin-bottom: 10px;">Network Architecture</h4>
                            <p><strong>Input Layer:</strong> ${network.layers[0].size} neurons (Stress, Sleep)</p>
                            <p><strong>Hidden Layer:</strong> ${network.layers[1].size} neurons</p>
                            <p><strong>Output Layer:</strong> ${network.layers[2].size} neuron (Risk Probability)</p>
                            <p><strong>Total Parameters:</strong> ${getTotalParameters(network)}</p>
                        </div>
                        <div>
                            <h4 style="color: #00ff00; margin-bottom: 10px;">Training Results</h4>
                            <p><strong>Final Accuracy:</strong> ${(finalAccuracy * 100).toFixed(1)}%</p>
                            <p><strong>Final Loss:</strong> ${finalLoss.toFixed(4)}</p>
                            <p><strong>Sample Prediction:</strong></p>
                            <p>Input: [${sampleData.input.map(x => x.toFixed(2)).join(', ')}]</p>
                            <p>Output: ${prediction[0].toFixed(3)} (${prediction[0] > 0.5 ? 'High Risk' : 'Low Risk'})</p>
                            <p>Actual: ${sampleData.target === 1 ? 'High Risk' : 'Low Risk'}</p>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <h4 style="color: #ffc107;">Sample Weights (Hidden Layer ‚Üí Output)</h4>
                        <p style="font-family: monospace; background: rgba(0,217,255,0.1); padding: 8px; border-radius: 5px;">
                            [${network.layers[2].weights[0].slice(0, 5).map(w => w.toFixed(3)).join(', ')}...]
                        </p>
                    </div>
                `;
            } else {
                const finalLoss = trainingResults[trainingResults.length - 1].loss;
                
                resultsDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                        <div>
                            <h4 style="color: #00d9ff; margin-bottom: 10px;">Network Architecture</h4>
                            <p><strong>Input Layer:</strong> ${network.layers[0].size} neurons (Anxiety, Depression)</p>
                            <p><strong>Hidden Layer:</strong> ${network.layers[1].size} neurons</p>
                            <p><strong>Output Layer:</strong> ${network.layers[2].size} neurons (Cluster Prob.)</p>
                            <p><strong>Total Parameters:</strong> ${getTotalParameters(network)}</p>
                        </div>
                        <div>
                            <h4 style="color: #00ff00; margin-bottom: 10px;">Clustering Results</h4>
                            <p><strong>Final Reconstruction Loss:</strong> ${finalLoss.toFixed(4)}</p>
                            <p><strong>Sample Clustering:</strong></p>
                            <p>Input: [${sampleData.input.map(x => x.toFixed(2)).join(', ')}]</p>
                            <p>Cluster Probabilities: [${prediction.map(p => p.toFixed(3)).join(', ')}]</p>
                            <p>Predicted Cluster: ${prediction.indexOf(Math.max(...prediction))}</p>
                            <p>Actual Cluster: ${sampleData.cluster}</p>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <h4 style="color: #ffc107;">Sample Weights (Input ‚Üí Hidden)</h4>
                        <p style="font-family: monospace; background: rgba(0,217,255,0.1); padding: 8px; border-radius: 5px;">
                            Neuron 1: [${network.layers[1].weights[0].map(w => w.toFixed(3)).join(', ')}]<br>
                            Neuron 2: [${network.layers[1].weights[1].map(w => w.toFixed(3)).join(', ')}]
                        </p>
                    </div>
                `;
            }
            
        } catch (error) {
            console.error('Neural network plotting error:', error);
            document.getElementById('neural-network-results').innerHTML = `
                <p style="color: #ff6b6b;">Error displaying network: ${error.message}</p>
            `;
        }
    }
    
    function drawNeuralNetwork(ctx, network, width, height) {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, width, height);
        
        const layerSpacing = width / (network.layers.length + 1);
        const colors = ['#00d9ff', '#ffc107', '#00ff00'];
        
        // Draw connections first (behind neurons)
        for (let layerIdx = 0; layerIdx < network.layers.length - 1; layerIdx++) {
            const currentLayer = network.layers[layerIdx];
            const nextLayer = network.layers[layerIdx + 1];
            
            const currentX = layerSpacing * (layerIdx + 1);
            const nextX = layerSpacing * (layerIdx + 2);
            
            for (let i = 0; i < currentLayer.size; i++) {
                const currentY = (height / (currentLayer.size + 1)) * (i + 1);
                
                for (let j = 0; j < nextLayer.size; j++) {
                    const nextY = (height / (nextLayer.size + 1)) * (j + 1);
                    
                    // Get weight strength for line thickness
                    const weight = layerIdx === 0 ? 
                        (nextLayer.weights[j] ? nextLayer.weights[j][i] : 0) :
                        (nextLayer.weights[j] ? nextLayer.weights[j][i] : 0);
                    
                    const opacity = Math.min(1, Math.abs(weight));
                    const lineWidth = Math.max(0.5, Math.abs(weight) * 3);
                    
                    ctx.strokeStyle = weight > 0 ? 
                        `rgba(0, 217, 255, ${opacity * 0.6})` : 
                        `rgba(255, 99, 132, ${opacity * 0.6})`;
                    ctx.lineWidth = lineWidth;
                    
                    ctx.beginPath();
                    ctx.moveTo(currentX, currentY);
                    ctx.lineTo(nextX, nextY);
                    ctx.stroke();
                }
            }
        }
        
        // Draw neurons
        for (let layerIdx = 0; layerIdx < network.layers.length; layerIdx++) {
            const layer = network.layers[layerIdx];
            const x = layerSpacing * (layerIdx + 1);
            const neuronSpacing = height / (layer.size + 1);
            
            for (let neuronIdx = 0; neuronIdx < layer.size; neuronIdx++) {
                const y = neuronSpacing * (neuronIdx + 1);
                const activation = layer.neurons[neuronIdx] || 0;
                
                // Draw neuron circle
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, 2 * Math.PI);
                ctx.fillStyle = colors[layerIdx];
                ctx.fill();
                
                // Draw activation level
                if (activation > 0) {
                    ctx.beginPath();
                    ctx.arc(x, y, 10, 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(255, 255, 255, ${activation})`;
                    ctx.fill();
                }
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw neuron number
                ctx.fillStyle = '#000000';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(neuronIdx.toString(), x, y + 3);
            }
            
            // Draw layer labels
            ctx.fillStyle = colors[layerIdx];
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(layer.name, x, height - 10);
        }
    }
    
    function getTotalParameters(network) {
        let total = 0;
        for (let i = 1; i < network.layers.length; i++) {
            const layer = network.layers[i];
            // Weights + biases
            total += layer.weights.length * layer.weights[0].length + layer.biases.length;
        }
        return total;
    }
    
    // --- GRADIENT DESCENT DEMO FUNCTION ---
    function runGradientDescentDemo() {
        try {
            // Check if Chart.js is available
            if (typeof Chart === 'undefined') {
                throw new Error('Chart.js library is not loaded');
            }
            
            const learningRate = parseFloat(document.getElementById('grad-learning-rate').value);
            const epochs = parseInt(document.getElementById('grad-epochs').value);
            
            // Update display values
            document.getElementById('grad-lr-val').textContent = learningRate;
            document.getElementById('grad-epochs-val').textContent = epochs;
            
            console.log(`Running gradient descent: LR=${learningRate}, epochs=${epochs}`);
            
            // Generate simple quadratic loss surface (w^2 + b^2)
            // This creates a bowl-shaped loss surface with minimum at (0, 0)
            const n = 50;
            const trainingData = [];
            
            // Create synthetic data where optimal solution is w=2, b=1
            for (let i = 0; i < n; i++) {
                const x = Math.random() * 10 - 5;
                const y = 2 * x + 1 + (Math.random() - 0.5) * 0.5; // Less noise for cleaner demo
                trainingData.push({ x, y });
            }
            
            // Initialize weights far from optimum to show dramatic descent
            let w = Math.random() * 6 - 3; // Start between -3 and 3
            let b = Math.random() * 6 - 3; // Start between -3 and 3
            
            const optimizationPath = [];
            const lossHistory = [];
            
            // Store initial position
            optimizationPath.push({ w: w, b: b, epoch: 0 });
            
            // Gradient descent training loop
            for (let epoch = 0; epoch < epochs; epoch++) {
                let totalLoss = 0;
                let dW = 0;
                let dB = 0;
                
                // Forward pass and compute gradients
                for (let i = 0; i < trainingData.length; i++) {
                    const x = trainingData[i].x;
                    const yTrue = trainingData[i].y;
                    
                    // Forward pass: y_pred = w * x + b
                    const yPred = w * x + b;
                    
                    // Compute loss: L = 0.5 * (y_true - y_pred)^2
                    const loss = 0.5 * Math.pow(yTrue - yPred, 2);
                    totalLoss += loss;
                    
                    // Compute gradients
                    const error = yPred - yTrue;
                    dW += error * x;
                    dB += error;
                }
                
                // Average gradients
                dW /= trainingData.length;
                dB /= trainingData.length;
                
                // Update weights using gradient descent
                w -= learningRate * dW;
                b -= learningRate * dB;
                
                // Store history
                const avgLoss = totalLoss / trainingData.length;
                lossHistory.push({ x: epoch, y: avgLoss });
                optimizationPath.push({ w: w, b: b, epoch: epoch + 1, loss: avgLoss });
            }
            
            // Plot 3D-style loss surface with optimization path
            plotGradientDescentPath(optimizationPath, lossHistory, learningRate, epochs);
            
        } catch (error) {
            console.error('Gradient descent demo error:', error);
            document.getElementById('gradient-descent-results').innerHTML = `
                <p style="color: #ff6b6b;">Error running gradient descent demo: ${error.message}</p>
            `;
        }
    }
    
    function plotGradientDescentPath(optimizationPath, lossHistory, learningRate, epochs) {
        try {
            const canvas = document.getElementById('gradient-descent-demo');
            if (!canvas) {
                throw new Error('Canvas element not found');
            }
            
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                throw new Error('Cannot get canvas context');
            }
            
            // Clear canvas and set size
            canvas.width = canvas.offsetWidth;
            canvas.height = 250;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw loss surface contour and optimization path
            drawLossSurfaceWithPath(ctx, optimizationPath, canvas.width, canvas.height);
            
            // Display results
            const finalPath = optimizationPath[optimizationPath.length - 1];
            const initialLoss = optimizationPath[0].loss || lossHistory[0].y;
            const finalLoss = finalPath.loss || lossHistory[lossHistory.length - 1].y;
            const lossReduction = ((initialLoss - finalLoss) / initialLoss * 100).toFixed(1);
            
            document.getElementById('gradient-descent-results').innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                    <div>
                        <h4 style="color: #00d9ff;">Optimization Path</h4>
                        <p><strong>Starting Point:</strong> w=${optimizationPath[0].w.toFixed(3)}, b=${optimizationPath[0].b.toFixed(3)}</p>
                        <p><strong>Final Point:</strong> w=${finalPath.w.toFixed(3)}, b=${finalPath.b.toFixed(3)}</p>
                        <p><strong>Total Steps:</strong> ${epochs}</p>
                        <p><strong>Learning Rate:</strong> ${learningRate}</p>
                    </div>
                    <div>
                        <h4 style="color: #00ff00;">Loss Reduction</h4>
                        <p><strong>Initial Loss:</strong> ${initialLoss.toFixed(4)}</p>
                        <p><strong>Final Loss:</strong> ${finalLoss.toFixed(4)}</p>
                        <p><strong>Reduction:</strong> ${lossReduction}%</p>
                        <p><strong>Status:</strong> ${finalLoss < 0.1 ? 'Converged!' : finalLoss < 1.0 ? 'Good progress' : 'Still optimizing'}</p>
                    </div>
                </div>
                <div style="margin-top: 15px;">
                    <h4 style="color: #ffc107;">Mathematical Process</h4>
                    <p style="font-family: monospace; background: rgba(0,217,255,0.1); padding: 8px; border-radius: 5px;">
                        Loss(w,b) = ¬ΩŒ£(y_true - (w√óx + b))¬≤<br>
                        ‚àÇLoss/‚àÇw = Œ£(y_pred - y_true) √ó x<br>
                        ‚àÇLoss/‚àÇb = Œ£(y_pred - y_true)<br>
                        w_new = w_old - Œ± √ó ‚àÇLoss/‚àÇw<br>
                        b_new = b_old - Œ± √ó ‚àÇLoss/‚àÇb
                    </p>
                </div>
            `;
            
        } catch (error) {
            console.error('Error plotting gradient descent:', error);
            document.getElementById('gradient-descent-results').innerHTML = `
                <p style="color: #ff6b6b;">Error plotting results: ${error.message}</p>
            `;
        }
    }
    
    function drawLossSurfaceWithPath(ctx, path, width, height) {
        // Fill background
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, width, height);
        
        // Create coordinate system
        const padding = 40;
        const plotWidth = width - 2 * padding;
        const plotHeight = height - 2 * padding;
        
        // Find bounds for weights
        const wValues = path.map(p => p.w);
        const bValues = path.map(p => p.b);
        const wMin = Math.min(...wValues) - 1;
        const wMax = Math.max(...wValues) + 1;
        const bMin = Math.min(...bValues) - 1;
        const bMax = Math.max(...bValues) + 1;
        
        // Draw loss surface contours (simplified representation)
        ctx.strokeStyle = 'rgba(0, 217, 255, 0.2)';
        ctx.lineWidth = 1;
        
        // Draw concentric ellipses to represent loss contours
        const centerX = padding + plotWidth * 0.7; // Offset to show descent
        const centerY = padding + plotHeight * 0.7;
        
        for (let i = 1; i <= 5; i++) {
            const radiusX = (plotWidth / 6) * i;
            const radiusY = (plotHeight / 8) * i;
            
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        // Draw optimization path
        ctx.strokeStyle = '#ff6384';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        for (let i = 0; i < path.length; i++) {
            const w = path[i].w;
            const b = path[i].b;
            
            // Map to canvas coordinates
            const x = padding + ((w - wMin) / (wMax - wMin)) * plotWidth;
            const y = padding + plotHeight - ((b - bMin) / (bMax - bMin)) * plotHeight;
            
            if (i === 0) {
                ctx.moveTo(x, y);
                
                // Draw starting point
                ctx.save();
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
                
                // Label starting point
                ctx.fillStyle = '#00ff00';
                ctx.font = '12px Arial';
                ctx.fillText('Start', x + 10, y - 10);
            } else {
                ctx.lineTo(x, y);
            }
            
            // Draw intermediate points
            if (i > 0 && i % 5 === 0) {
                ctx.save();
                ctx.fillStyle = '#ffc107';
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
            }
        }
        
        ctx.stroke();
        
        // Draw final point
        if (path.length > 0) {
            const finalPoint = path[path.length - 1];
            const finalX = padding + ((finalPoint.w - wMin) / (wMax - wMin)) * plotWidth;
            const finalY = padding + plotHeight - ((finalPoint.b - bMin) / (bMax - bMin)) * plotHeight;
            
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(finalX, finalY, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Label final point
            ctx.fillStyle = '#ff0000';
            ctx.font = '12px Arial';
            ctx.fillText('End', finalX + 10, finalY + 20);
        }
        
        // Draw axes labels
        ctx.fillStyle = '#00d9ff';
        ctx.font = '14px Arial';
        ctx.fillText('Weight (w)', width / 2 - 30, height - 10);
        
        ctx.save();
        ctx.translate(15, height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Bias (b)', 0, 0);
        ctx.restore();
        
        // Add title
        ctx.fillStyle = '#00d9ff';
        ctx.font = '16px Arial';
        ctx.fillText('Gradient Descent Optimization Path', padding, 25);
        
        // Add arrow showing descent direction
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(width - 100, 40);
        ctx.lineTo(width - 60, 70);
        ctx.stroke();
        
        // Arrow head
        ctx.beginPath();
        ctx.moveTo(width - 60, 70);
        ctx.lineTo(width - 65, 65);
        ctx.moveTo(width - 60, 70);
        ctx.lineTo(width - 55, 65);
        ctx.stroke();
        
        ctx.fillStyle = '#ffff00';
        ctx.font = '12px Arial';
        ctx.fillText('Descent', width - 100, 35);
    }
    
    // --- LINEAR REGRESSION FUNCTIONS ---
    function generateLinearRegression() {
        const n = parseInt(document.getElementById('linear-n').value);
        const noise = parseFloat(document.getElementById('linear-noise').value);
        
        // Generate data points
        const data = [];
        const trueSlope = 2.5;
        const trueIntercept = 1.2;
        
        for (let i = 0; i < n; i++) {
            const x = Math.random() * 10; // Random x between 0 and 10
            const y = trueIntercept + trueSlope * x + (Math.random() - 0.5) * noise * 10;
            data.push({ x: x, y: y });
        }
        
        // Update display values
        document.getElementById('linear-n-val').textContent = n;
        document.getElementById('linear-noise-val').textContent = noise;
        
        // Fit regression line
        const n_points = data.length;
        const sum_x = data.reduce((sum, point) => sum + point.x, 0);
        const sum_y = data.reduce((sum, point) => sum + point.y, 0);
        const sum_xy = data.reduce((sum, point) => sum + point.x * point.y, 0);
        const sum_xx = data.reduce((sum, point) => sum + point.x * point.x, 0);
        
        const slope = (n_points * sum_xy - sum_x * sum_y) / (n_points * sum_xx - sum_x * sum_x);
        const intercept = (sum_y - slope * sum_x) / n_points;
        
        // Calculate R-squared
        const y_mean = sum_y / n_points;
        const ss_tot = data.reduce((sum, point) => sum + Math.pow(point.y - y_mean, 2), 0);
        const ss_res = data.reduce((sum, point) => {
            const y_pred = intercept + slope * point.x;
            return sum + Math.pow(point.y - y_pred, 2);
        }, 0);
        const r_squared = 1 - (ss_res / ss_tot);
        
        // Create regression line points
        const x_min = Math.min(...data.map(p => p.x));
        const x_max = Math.max(...data.map(p => p.x));
        const line_points = [
            { x: x_min, y: intercept + slope * x_min },
            { x: x_max, y: intercept + slope * x_max }
        ];
        
        // Plot the data
        const canvas = document.getElementById('linear-plot');
        const ctx = canvas.getContext('2d');
        
        if (window.linearChart) {
            window.linearChart.destroy();
        }
        
        window.linearChart = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Data Points',
                    data: data,
                    backgroundColor: 'rgba(0, 217, 255, 0.6)',
                    pointRadius: 4
                }, {
                    label: 'Regression Line',
                    data: line_points,
                    type: 'line',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'transparent',
                    borderWidth: 3,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Linear Regression Analysis',
                        color: '#00d9ff'
                    },
                    legend: {
                        labels: {
                            color: '#00d9ff'
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'X Variable',
                            color: '#00d9ff'
                        },
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Y Variable',
                            color: '#00d9ff'
                        },
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    }
                }
            }
        });
        
        // Display results
        document.getElementById('linear-results').innerHTML = `
            <h4>Linear Regression Results</h4>
            <p><strong>Equation:</strong> y = ${intercept.toFixed(3)} + ${slope.toFixed(3)}x</p>
            <p><strong>R¬≤:</strong> ${r_squared.toFixed(3)} (${(r_squared * 100).toFixed(1)}% variance explained)</p>
            <p><strong>Sample Size:</strong> n = ${n_points}</p>
            <p><strong>True Values:</strong> y = ${trueIntercept} + ${trueSlope}x</p>
        `;
        
        // Generate residual plot
        generateResidualPlot(data, intercept, slope);
    }

    function generateResidualPlot(data, intercept, slope) {
        const residuals = data.map(point => {
            const predicted = intercept + slope * point.x;
            return {
                x: predicted,
                y: point.y - predicted
            };
        });
        
        const residualCanvas = document.getElementById('residual-plot');
        const residualCtx = residualCanvas.getContext('2d');
        
        if (window.residualChart) {
            window.residualChart.destroy();
        }
        
        window.residualChart = new Chart(residualCtx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Residuals',
                    data: residuals,
                    backgroundColor: 'rgba(255, 99, 132, 0.6)',
                    pointRadius: 3
                }, {
                    label: 'Zero Line',
                    data: [
                        { x: Math.min(...residuals.map(r => r.x)), y: 0 },
                        { x: Math.max(...residuals.map(r => r.x)), y: 0 }
                    ],
                    type: 'line',
                    borderColor: 'rgba(255, 206, 84, 1)',
                    borderDash: [5, 5],
                    borderWidth: 2,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: 'Residuals vs Fitted Values',
                        color: '#00d9ff'
                    },
                    legend: {
                        labels: {
                            color: '#00d9ff'
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Fitted Values',
                            color: '#00d9ff'
                        },
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Residuals',
                            color: '#00d9ff'
                        },
                        ticks: {
                            color: '#00d9ff'
                        },
                        grid: {
                            color: 'rgba(0, 217, 255, 0.3)'
                        }
                    }
                }
            }
        });
    }

    // --- FOURIER ANALYSIS FUNCTIONS ---
    function runFourierAnalysis() {
        const freq = parseInt(document.getElementById('fourier-freq').value);
        const noise = parseFloat(document.getElementById('fourier-noise').value);
        
        // Update display values
        document.getElementById('fourier-freq-val').textContent = freq;
        document.getElementById('fourier-noise-val').textContent = noise;
        
        // Generate time domain signal with multiple components
        const fs = 128; // Sampling frequency
        const duration = 2; // 2 seconds
        const N = fs * duration;
        const t = Array.from({length: N}, (_, i) => i / fs);
        
        // Create signal with primary frequency + harmonics + noise
        const signal = t.map(time => {
            const primary = Math.sin(2 * Math.PI * freq * time);
            const harmonic = 0.3 * Math.sin(2 * Math.PI * (freq * 2) * time);
            const lowFreq = 0.2 * Math.sin(2 * Math.PI * (freq * 0.5) * time);
            const noiseComponent = noise * (Math.random() - 0.5) * 2;
            return primary + harmonic + lowFreq + noiseComponent;
        });
        
        // Compute power spectrum using simplified FFT approach
        const freqs = Array.from({length: N/2}, (_, i) => i * fs / N);
        const magnitude = new Array(N/2);
        
        // Simplified DFT for demonstration
        for (let k = 0; k < N/2; k++) {
            let real = 0, imag = 0;
            for (let n = 0; n < N; n++) {
                const angle = -2 * Math.PI * k * n / N;
                real += signal[n] * Math.cos(angle);
                imag += signal[n] * Math.sin(angle);
            }
            magnitude[k] = Math.sqrt(real * real + imag * imag) / N * 2; // Normalize
        }
        
        // Plot time domain (show first 1 second for clarity)
        const timeCtx = document.getElementById('time-domain-chart').getContext('2d');
        if (window.timeChart) window.timeChart.destroy();
        
        const displayPoints = 128; // Show 1 second of data
        window.timeChart = new Chart(timeCtx, {
            type: 'line',
            data: {
                labels: t.slice(0, displayPoints).map(x => x.toFixed(2)),
                datasets: [{
                    label: 'EEG-like Signal',
                    data: signal.slice(0, displayPoints),
                    borderColor: '#00d9ff',
                    backgroundColor: 'rgba(0, 217, 255, 0.1)',
                    borderWidth: 1.5,
                    pointRadius: 0,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                plugins: { 
                    legend: { display: true },
                    title: { display: true, text: 'Time Domain Signal' }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Time (s)' },
                        ticks: { maxTicksLimit: 10 }
                    },
                    y: { title: { display: true, text: 'Amplitude (ŒºV)' } }
                },
                elements: { line: { tension: 0 } }
            }
        });
        
        // Plot frequency domain (show up to 50 Hz)
        const freqCtx = document.getElementById('frequency-domain-chart').getContext('2d');
        if (window.freqChart) window.freqChart.destroy();
        
        const maxFreqIndex = Math.min(50, freqs.length);
        window.freqChart = new Chart(freqCtx, {
            type: 'bar',
            data: {
                labels: freqs.slice(1, maxFreqIndex).map(x => x.toFixed(1)), // Skip DC component
                datasets: [{
                    label: 'Power Spectrum',
                    data: magnitude.slice(1, maxFreqIndex),
                    backgroundColor: 'rgba(255, 107, 107, 0.7)',
                    borderColor: '#ff6b6b',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: { 
                    legend: { display: true },
                    title: { display: true, text: 'Frequency Domain (FFT)' }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Frequency (Hz)' },
                        ticks: { maxTicksLimit: 15 }
                    },
                    y: { 
                        title: { display: true, text: 'Magnitude' },
                        beginAtZero: true
                    }
                }
            }
        });
    }

    // --- STFT ANALYSIS FUNCTIONS ---
    function runSTFTAnalysis() {
        const windowSize = parseInt(document.getElementById('stft-window').value);
        document.getElementById('stft-window-val').textContent = windowSize;
        
        // Generate chirp signal (frequency sweeping from 5 to 25 Hz)
        const fs = 128;
        const duration = 3;
        const N = fs * duration;
        const t = Array.from({length: N}, (_, i) => i / fs);
        
        // Chirp signal: frequency increases linearly with time
        const f0 = 5; // Start frequency
        const f1 = 25; // End frequency
        const signal = t.map(time => {
            const instantFreq = f0 + (f1 - f0) * time / duration;
            return Math.sin(2 * Math.PI * instantFreq * time) + 0.2 * Math.sin(2 * Math.PI * 40 * time);
        });
        
        // Create spectrogram using canvas drawing for better visualization
        const canvas = document.getElementById('stft-spectrogram');
        const ctx = canvas.getContext('2d');
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Set canvas size
        canvas.width = 400;
        canvas.height = 200;
        
        // STFT parameters
        const overlap = 0.75;
        const hop = Math.floor(windowSize * (1 - overlap));
        const timeSteps = Math.floor((N - windowSize) / hop) + 1;
        const freqBins = Math.floor(windowSize / 2);
        
        // Compute spectrogram
        const spectrogram = [];
        for (let i = 0; i < timeSteps; i++) {
            const start = i * hop;
            const end = start + windowSize;
            const windowData = signal.slice(start, end);
            
            // Apply Hanning window
            const windowed = windowData.map((val, idx) => {
                const hanningVal = 0.5 * (1 - Math.cos(2 * Math.PI * idx / (windowSize - 1)));
                return val * hanningVal;
            });
            
            // Compute FFT magnitude for this window
            const magnitude = [];
            for (let k = 0; k < freqBins; k++) {
                let real = 0, imag = 0;
                for (let n = 0; n < windowSize; n++) {
                    const angle = -2 * Math.PI * k * n / windowSize;
                    real += windowed[n] * Math.cos(angle);
                    imag += windowed[n] * Math.sin(angle);
                }
                magnitude[k] = Math.sqrt(real * real + imag * imag);
            }
            spectrogram.push(magnitude);
        }
        
        // Find max value for normalization
        const maxVal = Math.max(...spectrogram.flat());
        
        // Draw spectrogram
        const pixelWidth = canvas.width / timeSteps;
        const pixelHeight = canvas.height / freqBins;
        
        for (let t = 0; t < timeSteps; t++) {
            for (let f = 0; f < freqBins; f++) {
                const value = spectrogram[t][f] / maxVal;
                const intensity = Math.pow(value, 0.5); // Gamma correction for better visibility
                
                // Color mapping: blue to red through yellow
                let r, g, b;
                if (intensity < 0.5) {
                    r = 0;
                    g = Math.floor(intensity * 2 * 255);
                    b = Math.floor((1 - intensity * 2) * 255);
                } else {
                    r = Math.floor((intensity - 0.5) * 2 * 255);
                    g = 255;
                    b = 0;
                }
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(
                    t * pixelWidth, 
                    canvas.height - (f + 1) * pixelHeight, 
                    pixelWidth, 
                    pixelHeight
                );
            }
        }
        
        // Add labels
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.fillText('Time ‚Üí', 10, canvas.height - 5);
        ctx.save();
        ctx.translate(15, canvas.height - 50);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Frequency ‚Üë', 0, 0);
        ctx.restore();
        
        // Add title
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px Arial';
        ctx.fillText('STFT Spectrogram (Chirp Signal)', 10, 20);
    }

    // --- WAVELET ANALYSIS FUNCTIONS ---
    function runWaveletAnalysis() {
        const centerFreq = parseInt(document.getElementById('wavelet-freq').value);
        document.getElementById('wavelet-freq-val').textContent = centerFreq;
        
        // Generate EEG-like signal with different frequency components over time
        const fs = 128;
        const duration = 4;
        const N = fs * duration;
        const t = Array.from({length: N}, (_, i) => i / fs);
        
        // Multi-component signal simulating EEG states
        const signal = t.map(time => {
            let amplitude = 0;
            
            // Eyes closed alpha (8-12 Hz) in first second
            if (time < 1) {
                amplitude += 1.5 * Math.sin(2 * Math.PI * 10 * time);
            }
            // Transition to beta (13-25 Hz) in second 1-2
            else if (time < 2) {
                const alpha = 1.5 * Math.sin(2 * Math.PI * 10 * time) * (2 - time);
                const beta = 1.2 * Math.sin(2 * Math.PI * 18 * time) * (time - 1);
                amplitude += alpha + beta;
            }
            // High beta/gamma burst (25-40 Hz) in second 2-3
            else if (time < 3) {
                amplitude += 1.0 * Math.sin(2 * Math.PI * 30 * time);
            }
            // Return to mixed alpha/theta in last second
            else {
                amplitude += 0.8 * Math.sin(2 * Math.PI * 8 * time) + 
                           0.6 * Math.sin(2 * Math.PI * 6 * time);
            }
            
            // Add some noise
            amplitude += 0.2 * (Math.random() - 0.5);
            return amplitude;
        });
        
        // Create wavelet scalogram using canvas
        const canvas = document.getElementById('wavelet-scalogram');
        const ctx = canvas.getContext('2d');
        
        // Clear and resize canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = 400;
        canvas.height = 200;
        
        // Wavelet parameters
        const scales = 64; // Number of scales
        const minFreq = 1;
        const maxFreq = 50;
        const timeSteps = 80; // Subsample for visualization
        
        // Create scalogram matrix
        const scalogram = [];
        
        for (let scaleIdx = 0; scaleIdx < scales; scaleIdx++) {
            const freq = minFreq + (maxFreq - minFreq) * scaleIdx / scales;
            const scale = fs / freq; // Convert frequency to scale
            const timeRow = [];
            
            for (let timeIdx = 0; timeIdx < timeSteps; timeIdx++) {
                const timePoint = Math.floor(timeIdx * N / timeSteps);
                
                // Simplified Morlet wavelet convolution
                let real = 0, imag = 0;
                const sigma = scale / 4; // Wavelet width
                
                for (let i = 0; i < N; i++) {
                    const tau = (i - timePoint) / fs;
                    if (Math.abs(tau) < 3 * sigma) { // Only compute within 3 sigma
                        const envelope = Math.exp(-tau * tau / (2 * sigma * sigma));
                        const oscillation = 2 * Math.PI * freq * tau;
                        
                        real += signal[i] * envelope * Math.cos(oscillation);
                        imag += signal[i] * envelope * Math.sin(oscillation);
                    }
                }
                
                const magnitude = Math.sqrt(real * real + imag * imag);
                timeRow.push(magnitude);
            }
            scalogram.push(timeRow);
        }
        
        // Find max value for normalization
        const maxVal = Math.max(...scalogram.flat());
        
        // Draw scalogram
        const pixelWidth = canvas.width / timeSteps;
        const pixelHeight = canvas.height / scales;
        
        for (let t = 0; t < timeSteps; t++) {
            for (let s = 0; s < scales; s++) {
                const value = scalogram[s][t] / maxVal;
                const intensity = Math.pow(value, 0.3); // Strong gamma correction
                
                // Jet colormap: blue -> cyan -> yellow -> red
                let r, g, b;
                if (intensity < 0.25) {
                    r = 0;
                    g = Math.floor(intensity * 4 * 255);
                    b = 255;
                } else if (intensity < 0.5) {
                    r = 0;
                    g = 255;
                    b = Math.floor((1 - (intensity - 0.25) * 4) * 255);
                } else if (intensity < 0.75) {
                    r = Math.floor((intensity - 0.5) * 4 * 255);
                    g = 255;
                    b = 0;
                } else {
                    r = 255;
                    g = Math.floor((1 - (intensity - 0.75) * 4) * 255);
                    b = 0;
                }
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(
                    t * pixelWidth,
                    canvas.height - (s + 1) * pixelHeight,
                    pixelWidth,
                    pixelHeight
                );
            }
        }
        
        // Add labels and annotations
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        ctx.fillText('Time ‚Üí', 10, canvas.height - 5);
        ctx.save();
        ctx.translate(15, canvas.height - 50);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Frequency ‚Üë', 0, 0);
        ctx.restore();
        
        // Add title
        ctx.fillStyle = 'white';
        ctx.font = 'bold 14px Arial';
        ctx.fillText('Morlet Wavelet Scalogram (EEG-like)', 10, 20);
        
        // Add frequency labels
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        const freqLabels = [1, 8, 15, 30, 50];
        freqLabels.forEach(freq => {
            const yPos = canvas.height - (freq - minFreq) / (maxFreq - minFreq) * canvas.height;
            if (yPos > 0 && yPos < canvas.height) {
                ctx.fillText(`${freq}Hz`, canvas.width - 30, yPos);
            }
        });
    }

</script>
</body>
</html>